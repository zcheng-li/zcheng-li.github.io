[{"id":0,"href":"/docs/example/my-blog/pns/pns_ch1/","title":"CH1.è§„åˆ’è°ƒåº¦: è§’è‰²ä¸å½±å“","section":"å·¥ä¸šç”Ÿäº§è§„åˆ’è°ƒåº¦é˜…è¯»ç¬”è®°","content":" 1.1 Planning and Scheduling: Role and Impact # è§„åˆ’ ä¸ è°ƒåº¦ æ˜¯ å†³ç­–åˆ¶å®š (decision-making) ä¸€ç§å½¢å¼.\nå†³ç­–åˆ¶å®š åœ¨åˆ¶é€ æœåŠ¡äº§ä¸šä¸­ å¯ä»¥ç”¨æ¥\né‡‡è´­ä¸ç”Ÿäº§ (procurement and production) è¿è¾“ä¸åˆ†å‘ (transportation and distribution) ä¿¡æ¯å¤„ç†ä¸é€šè®¯ (information processing and communication) ç­‰ç­‰.\næˆ‘ä»¬å¸Œæœ›æˆ‘ä»¬çš„è§„åˆ’ä¸è°ƒåº¦ç®—æ³•å¯ä»¥åšåˆ°:\nallocate limited resources to the activities to be done so that the company can optimize its objectives and achieve its goals.\nè¿™é‡Œçš„ èµ„æº (resources) ä¸€èˆ¬å¯ä»¥æ˜¯:\nè½¦é—´é‡Œçš„æœºå™¨ (machines in a workshop) é£æœºåœºçš„è·‘é“ (runways at an airport) å·¥åœ°çš„å‘˜å·¥ (crews at a construction site) è®¡ç®—æœºçš„å¤„ç†å•å…ƒ (processing units in a computing environment) è¡ŒåŠ¨ (activities) ä¸€èˆ¬å¯ä»¥æ˜¯:\nè½¦é—´é‡Œæœºå™¨çš„è¿è¡Œå¤„ç†è¡ŒåŠ¨ (operations in a workshop) æœºåœºé‡Œé£æœºçš„èµ·é£é™è½è¡ŒåŠ¨ (take-oï¬€s and landings at an airport) å·¥åœ°é¡¹ç›®çš„ä¸€ä¸ªé˜¶æ®µ? (stages in a construction project) è®¡ç®—æœºç¨‹åºçš„æ‰§è¡Œ (computer programs that have to be executed) ç›®æ ‡ (objectives) æœ‰å¾ˆå¤šç§å½¢å¼, ä¸€èˆ¬å¯ä»¥æ˜¯:\nå‡å°‘å®Œæˆæ‰€æœ‰ ä»»åŠ¡ çš„æ€»æ—¶é—´ å‡å°‘è¶…æ—¶å®Œæˆçš„ ä»»åŠ¡ çš„æ•°é‡ ç„¶åä¹¦ä¸Šä¾‹ä¸¾äº†10ä¸ªä¾‹å­æ¥è¯´æ˜è¿™äº›æ¦‚å¿µ (ç•¥).\n1.2 Planning and Scheduling Functions in an Enterprise # Planning and Scheduling in Manufacturing. # åœ¨åˆ¶é€ ä¸šä¸­, æ¯ä¸€ä»½ è®¢å• (order) éƒ½éœ€è¦è¢«æ‹†è§£æˆ æ‹¥æœ‰ æˆªæ­¢æ—¥æœŸ (due date) çš„ ä»»åŠ¡ (jobs).\nè¿™äº› ä»»åŠ¡ éœ€è¦ æœºå™¨ æŒ‰ç…§ä¸€å®šçš„é¡ºåºæ¥è¿›è¡Œå¤„ç†.\nç„¶è€Œ, å¤„ç†å¯èƒ½ä¼šè¢«å»¶è¿Ÿ, å¦‚æœé‡åˆ°æŸå°æœºå™¨å¾ˆå¿™çš„æƒ…å†µ. å› æ­¤, ä¸ºäº†å¤„ç† é«˜ä¼˜å…ˆçº§ä»»åŠ¡, æˆ‘ä»¬éœ€è¦ç”¨ æŠ¢å å¼è°ƒåº¦ (preemptions).\næœ‰æ—¶, æŸäº›çªå‘äº‹ä»¶ä¹Ÿéœ€è¦è¢«è€ƒè™‘è¿›æ¥, æ¯”å¦‚:\næœºå™¨åæ‰ è¶…å‡ºé¢„æœŸçš„å¤„ç†æ—¶é—´ åœ¨è¿™æ ·çš„åœºæ™¯ä¸‹, æˆ‘ä»¬çš„ ç›®æ ‡ å°±æ˜¯é«˜æ•ˆç‡å’Œå¯æ§ç”Ÿäº§.\næ¥ä¸‹æ¥, ä½œè€…å†æ¬¡å¼ºè°ƒäº† scheduling å’Œ planning çš„åŒºåˆ«:\nThe shopfloor is not the only part of the organization that impacts the scheduling process. The scheduling process also interacts with the production planning process, which handles medium- to long-term planning for the entire organization.\nç®€è¨€ä¹‹, scheduling ä¸ä»…ä¼šæ”¶åˆ°è½¦é—´æœ¬èº«çŠ¶å†µçš„å½±å“, åŒæ—¶ä¹Ÿä¼šæ”¶åˆ° planningçš„å½±å“, ä¹Ÿå°±æ˜¯ä½ é‡‡ç”¨çš„è§„åˆ’ç®—æ³•.\nåœ¨è¿™ä¸ªåœºæ™¯ä¸‹, è§„åˆ’ç®—æ³• çš„åˆ¶å®šä¸€èˆ¬ä¼šåŸºäºä»¥ä¸‹è€ƒé‡:\nä»“å‚¨æƒ…å†µ (inventory levels) éœ€æ±‚é¢„æµ‹ (demand forecasts) èµ„æºéœ€æ±‚ (resource requirements) åœ¨äº†è§£ä¸Šé¢è¿™äº›æ¦‚å¿µå, æˆ‘ä»¬å¯ä»¥å¼€å§‹çœ‹ä¸€ä¸ªæ›´è¯¦ç»†çš„ç”Ÿäº§ç³»ç»Ÿçš„ä¿¡æ¯æµå›¾:\né‡Œé¢æœ‰å¾ˆå¤šæ–°çš„æ¦‚å¿µ, æˆ‘ä»¬å¯ä»¥ä¸€ä¸ªä¸ªçœ‹. é¦–å…ˆ, æˆ‘ä»¬çš„å†…éƒ¨ç³»ç»Ÿè‚¯å®šæ˜¯è¦ä¸å¤–éƒ¨ç³»ç»Ÿè¿›è¡Œæ²Ÿé€šå’Œ(å¯¹é½)çš„:\nIn manufacturing, planning and scheduling has to interact with other decision making functions in the plant.\nå…¶ä¸­ä¸€ä¸ªæ¯”è¾ƒå¸¸è§çš„ç³»ç»Ÿæ˜¯ Material Requirements Planning (MRP) system. ç”±äºæ¯ä¸ª è°ƒåº¦ éƒ½éœ€è¦å·¥å‚èƒ½å¤Ÿåœ¨åˆ¶å®šæ—¶é—´æ—¶æ‹¥æœ‰è¶³å¤Ÿçš„ èµ„æº (resources) å’Œ åŸææ–™ (raw materials), æ‰€ä»¥ MRP ç³»ç»Ÿä¼šæ ¹æ®å½“å‰çš„ä»“å‚¨é‡æ¥å†³å®šä¹°å…¥åŸææ–™çš„æ—¶é—´. MRP ç›®å‰å·²ç»æœ‰æˆç†Ÿçš„å•†ä¸šè½¯ä»¶å¯ä»¥ä½¿ç”¨.\nå¦ä¸€ä¸ªå¸¸è§çš„ç³»ç»Ÿæ˜¯ Enterprise Resource Planning (ERP) systems. å°±æ˜¯ç”¨äºæŠŠå„ä¸ªç§äººç”µè„‘å’Œæ•°æ®ä¸­å¿ƒçš„æ•°æ®æ‹‰é½. æœ‰æ—¶ä¹Ÿä¼šä¸ä¾›åº”å•†/å®¢æˆ·çš„æ•°æ®ç›¸è¿. å†³ç­–è¾…åŠ©ç³»ç»Ÿä¸€èˆ¬éœ€è¦ä¸ ERP ç›¸è¿.\nPlanning and Scheduling in Services. # ç•¥\n1.3 Outline of the Book # "},{"id":1,"href":"/docs/example/my-blog/qam/","title":"åŠ¨æ€QAMè°ƒåˆ¶è§£è°ƒpythonå®ç°","section":"åšå®¢","content":" å¼•å…¥ # é¢˜ç›®åŸºäº University of Glasgow è¯¾ç¨‹ ENG3014 Communications Systems 3 çš„å¤§ä½œä¸š, å¸Œæœ›æˆ‘ä»¬ç”¨è¯¾ç¨‹å­¦åˆ°çš„çŸ¥è¯†å†™ä¸€ä¸ªç®€å•çš„ä¿¡æ¯æ”¶å‘æ¨¡æ‹Ÿç¨‹åº:\nThis should include at minimum:\nA message of your choice, comprising more than 2048 bits, converted from a â€œSTRINGâ€ to a â€œBINARYâ€. Using your modulation format of choice, modulate a carrier to encode this information. The channel SNR to be considered will be 6dB, 18dB and 24dB with respect to AGWN. An output filter limiting the transmitter bandwidth to less than 20% of the carrier frequency. Demodulation of the signal and recovery of the signal. Please analyse the Bit Error Rate of the received signal over multiple retransmission of the signal over the simulated channel. Discuss in your report choices you make, such as modulation format, Baud Rate, Filter type and bandwidth. Up to 30% of the marks allocated will be included for creative additions (10% each), these could include:\nSimulate fading conditions associated with an urban environment. Implementation of Hamming coding or other error correction technique. Transmission of video, audio or other time varying signal over the channel. Dynamic modulation, based on measured system performance. Automatic resending of errored signals. Or anything else you think would be a cool addition! :-(\nå½’çº³ä¸€ä¸‹å·®ä¸å¤šå¦‚ä¸‹:\nå°† String çš„è¾“å…¥è½¬åŒ–ä¸ºç”± 0 å’Œ 1 ç»„æˆçš„äºŒè¿›åˆ¶ç¼–ç . ç”¨ Hamming code ç¼–ç . åŠ å…¥å™ªéŸ³. é€‰ä¸€ä¸ªå–œæ¬¢çš„åŠæ³•è°ƒåˆ¶. å†è§£è°ƒ. è®¡ç®—è¯¯ç ç‡ç­‰å…¶å®ƒæŒ‡æ ‡. æˆ‘çš„é¡¹ç›®åšäº†ä¸‹é¢çš„æ­¥éª¤:\nå›¾1: å®ç°æµç¨‹å›¾ ä¸è¦æ…Œ, æˆ‘ä»¬ä¸€æ­¥æ­¥çœ‹ğŸ‘€.\nåº“ # import numpy as np from numpy import log2, arange, sqrt, flip, concatenate, zeros, array, floor, sqrt, array, bitwise_xor from numpy.random import randint import math from math import ceil from matplotlib import pyplot as plt from scipy import signal from hamming import encode, decode from bitarray import bitarray String ä¸ Binary çš„è½¬æ¢ # def string2bits(s=\u0026#39;\u0026#39;): out = \u0026#39;\u0026#39;.join([bin(ord(x))[2:].zfill(8) for x in s]) return [int(x) for x in list(out)] å¥½å¤šå¥‡å¥‡æ€ªæ€ªçš„å‡½æ•°ğŸ˜©.\nord(x): è¿”å›ä»£è¡¨å­—ç¬¦ x çš„ unicode ç¼–ç  (int), æ¯”æ–¹è¯´: â€˜aâ€™ çš„ unicode ç¼–ç æ˜¯ 97, â€˜?â€™ çš„æ˜¯ 63.\nbin(ord(x)): è¿”å›xçš„unicodeç¼–ç çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸² (string), æ³¨æ„:ord()çš„è¾“å‡ºæ˜¯åè¿›åˆ¶çš„å‘€. æ¯”å¦‚:\n'a' -\u0026gt; 97 -\u0026gt; \u0026quot;0b1100001\u0026quot;\n'?' -\u0026gt; 63 -\u0026gt; \u0026quot;0b111111\u0026quot;\næ³¨æ„åˆ°è¿™é‡Œçš„å­—ç¬¦ä¸²å‰é¢å¸¦äº† 0b, å› æ­¤æˆ‘ä»¬éœ€è¦:\nbin(ord(x))[2:]: å»æ‰ 0b\n'a' -\u0026gt; 97 -\u0026gt; \u0026quot;0b1100001\u0026quot; -\u0026gt; \u0026quot;1100001\u0026quot;\n'?' -\u0026gt; 63 -\u0026gt; \u0026quot;0b111111\u0026quot; -\u0026gt; \u0026quot;111111\u0026quot;\nåˆæ³¨æ„åˆ°æ¯ä¸ªå­—ç¬¦ä¸²é•¿åº¦ä¸ä¸€æ ·, è¿™å¯èƒ½ä¼šè®©æˆ‘ä»¬åœ¨è§£ç çš„æ—¶å€™å‡ºç°é—®é¢˜, å› æ­¤æˆ‘ä»¬éœ€è¦:\nbin(ord(x))[2:].zfill(8): è¡¥é½å­—ç¬¦ä¸²åˆ°8ä½\n'a' -\u0026gt; 97 -\u0026gt; \u0026quot;0b1100001\u0026quot; -\u0026gt; \u0026quot;1100001\u0026quot; -\u0026gt; \u0026quot;01100001\u0026quot;\n'?' -\u0026gt; 63 -\u0026gt; \u0026quot;0b111111\u0026quot;-\u0026gt; \u0026quot;111111\u0026quot; -\u0026gt; \u0026quot;00111111\u0026quot;\nout = ''.join([bin(ord(x))[2:].zfill(8) for x in s]): å°†æ‰€æœ‰å­—ç¬¦è½¬æ¢åçš„ 8 ä½äºŒè¿›åˆ¶æ‹¼æ¥æˆä¸€ä¸ªé•¿å­—ç¬¦ä¸².\n'a?' -\u0026gt; \u0026quot;0110000100111111\u0026quot;\nä½†æ˜¯å› ä¸ºæ•´å½¢(int)è¦æ›´å¥½å¤„ç†ä¸€äº›, æˆ‘ä»¬æœ€åå†æ¢ä¸€æ¢:\nreturn [int(x) for x in list(out)]: éå†æ¯ä¸€ä¸ªå­—ç¬¦ (char), å°†å…¶æ¢æˆæ•´å½¢ (int):\n'a?' -\u0026gt; \u0026quot;0110000100111111\u0026quot; -\u0026gt; [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1]\nå½“å½“~~\næ—¢ç„¶éƒ½æŠŠè¿™ä¹ˆä¹±ä¸ƒå…«ç³Ÿçš„è½¬æ¢ææ‡‚äº†, é‚£å°±ä¸å¦¨å†çœ‹çœ‹æ€ä¹ˆæŠŠå®ƒå˜å›å». (Binary -\u0026gt; String)\ndef bits2string(b=None): return \u0026#39;\u0026#39;.join([chr(int(x, 2)) for x in b]) é“ç†ä¹Ÿå¤§å·®ä¸å·®, [... for x in b] ç”¨æ¥éå†Binaryæ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ , int(x, 2) å°†äºŒè¿›åˆ¶çš„è¾“å…¥å˜æˆ 10 è¿›åˆ¶, chr() å†æŠŠå®ƒå˜æˆå­—ç¬¦, æœ€åå†ç”¨ ''.join() åˆå¹¶åœ¨ä¸€èµ·.\nAWGN å™ªéŸ³ # å’±å…ˆè·³è¿‡ Hamming Code, çœ‹çœ‹æ€ä¹ˆåŠ  AWGN å™ªéŸ³:\ndef awgn(signal, snr, seed=False): \u0026#39;\u0026#39;\u0026#39; Additive White Gaussian Noise (AWGN) function. \u0026#39;\u0026#39;\u0026#39; if seed: np.random.seed(1) # Calculate the signal power as the average of the squared magnitudes of the signal sigpower = sum([math.pow(abs(signal[A_I]), 2) for A_I in range(len(signal))]) sigpower = sigpower / len(signal) # Calculate the noise power based on the SNR # SNR (in linear scale) = Signal Power / Noise Power noisepower = sigpower / (math.pow(10, snr/10)) # Generate Gaussian noise with mean 0 and standard deviation based on noise power noise = np.random.normal(0, np.sqrt(noisepower), len(signal)) return np.array([noise]) å…¶ä¸­\nsigpower = sum([math.pow(abs(signal[A_I]), 2) for A_I in range(len(signal))]) sigpower = sigpower / len(signal) éå† signal (å³ä¹‹å‰æåˆ°çš„ [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1])ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ , å°†å…¶å¹³æ–¹ç›¸åŠ , ç„¶åå†é™¤ä»¥æ€»é•¿, è®¡ç®—ä¿¡å·åŠŸç‡.\né‚£ä¹ˆä¸ºä»€ä¹ˆè¦è®¡ç®—ä¿¡å·åŠŸç‡å‘¢? ç”±ä¿¡å™ªæ¯”å…¬å¼:\n\\[ \\mathrm{SNR}_{\\text{dB}} = 10 \\log_{10} \\left( \\frac{P_{\\text{signal}}}{P_{\\text{noise}}} \\right) \\] å…¶ä¸­:\n\\( \\mathrm{SNR}_{\\text{dB}} \\) : ä¿¡å™ªæ¯”ï¼ˆåˆ†è´è¡¨ç¤ºï¼‰ \\( P_{\\text{signal}} \\) : ä¿¡å·åŠŸç‡ \\( P_{\\text{noise}}ï¼š \\) : å™ªå£°åŠŸç‡ å› æ­¤, é€šè¿‡ç»™å®šçš„ä¿¡å™ªæ¯” SNR, æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¿¡å·åŠŸç‡åæ¨å‡ºåº”è¯¥åŠ å…¥çš„å™ªå£°åŠŸç‡. ä¹Ÿå°±æ˜¯è¿™ä¸€æ­¥:\nnoisepower = sigpower / (math.pow(10, snr/10)) ç„¶åå†é€šè¿‡è¿™ä¸€å™ªå£°åŠŸç‡è®¡ç®—å‡º AWGN (ä¹Ÿå°±æ˜¯è¿™ä¸ªå‡½æ•°çš„è¾“å‡º), æœ€åå’ŒåŸæœ¬çš„ä¿¡å·åšä¸ªåŠ æ³•å°±è¡Œå•¦~\n[0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1]\nSNR=24:\narray([[-0.03305892, 0.93648725, 1.07229167, 0.03032389, -0.08373429, -0.04651428, -0.02556458, 1.04447924, -0.04254978, -0.01583561, 1.01729117, 0.98901276, 1.01125261, 0.97203918, 1.07735198, 1.03366213]]) SNR=6:\narray([[ 0.15621611, 0.5966272 , 0.40825385, -0.03236429, 0.80902723, 0.67793688, 0.05471882, 1.1841027 , -0.48631011, -0.56585869, 1.15182751, 0.44881134, 0.74662291, 0.95341178, 0.9046891 , 0.71363364]]) å¯ä»¥æ˜æ˜¾å‘ç°ä¿¡å™ªæ¯” SNR è¶Šå¤§(å¦‚ SNR=24), å™ªéŸ³å¯¹ä¿¡å·çš„å½±å“è¶Šå°, åä¹‹, ä¿¡å™ªæ¯” SNR è¶Šå°(å¦‚ SNR=6), ä¿¡å·å°±å˜å¾—æ›´åŠ ä¹±ä¸ƒå…«ç³Ÿ.\nQAM è°ƒåˆ¶ # (è¯è¯´æ˜¯ä¸æ˜¯åº”è¯¥å…ˆè®²ä¸€è®² QAM æ˜¯ä»€ä¹ˆ?)\nQAM æ˜¯ä»€ä¹ˆ? # æ ¹æ®ç»´åŸºç™¾ç§‘:\nQuadrature amplitude modulation (QAM) is the name of a family of digital modulation methods and a related family of analog modulation methods widely used in modern telecommunications to transmit information. It conveys two analog message signals, or two digital bit streams, by changing (modulating) the amplitudes of two carrier waves, using the amplitude-shift keying (ASK) digital modulation scheme or amplitude modulation (AM) analog modulation scheme. The two carrier waves are of the same frequency and are out of phase with each other by 90Â°, a condition known as orthogonality or quadrature. The transmitted signal is created by adding the two carrier waves together. At the receiver, the two waves can be coherently separated (demodulated) because of their orthogonality.\n(å•Š, å¥½é•¿\u0026hellip;)\nä¸€å¥è¯, QAM çš„ä¼ è¾“æ•ˆç‡æ›´é«˜.\næ¯”å¦‚ QAM16 ä¸€æ¬¡å¯ä»¥ä¼ é€’ 4 bit, è€Œ AM ä¸€æ¬¡åªèƒ½ä¼  1 bit.\nå›¾2: å„ç§è°ƒåˆ¶æ–¹æ³•é€šé“å®¹é‡æ¯”è¾ƒ å¯¹äºæœ¬æ–‡ä¸­çš„ QAM çš„å®ç°, ç®€å•æ¥è¯´, å°±æ˜¯ä¸‰æ­¥: 1. å…ˆæŠŠè¾“å…¥æ•°ç»„å‡åˆ†æˆä¸¤ä»½, 2. å†é€šè¿‡å¹…ç§»é”®æ§ (ASK) ç¼–ç , 3. ç„¶åä¹˜ä¸Šå„è‡ªçš„è½½æ³¢å°±OKäº†. å¯ä»¥çœ‹çœ‹ç¤ºæ„å›¾:\nå›¾3: QAMè°ƒåˆ¶ç¤ºæ„å›¾ QAM åŸç† # è‡³äºå®ƒä¸ºä»€ä¹ˆèƒ½å¤ŸæˆåŠŸç¼–ç è§£ç , ç”¨å…¬å¼è¦æ›´å¥½ç†è§£ä¸€ç‚¹.\né¦–å…ˆå°†è¾“å…¥å‡åˆ†ä¸ºä¸¤åŠ, ç„¶ååˆ†åˆ«è®¡ç®—å¾—åˆ°å„è‡ªçš„ ASK ç¼–ç : \\( A_I(t) \\) å’Œ \\( A_Q(t) \\) .\n\\[ I(t) = A_I(t) cos(2\\pi f t) \\\\ Q(t) = A_Q(t) sin(2\\pi f t) \\] å…¶ä¸­, \\( f \\) æ˜¯è½½æ³¢çš„é¢‘ç‡. ç„¶åå°† \\( I(t) \\) å’Œ \\( Q(t) \\) å åŠ , å¾—åˆ°:\n\\[ I(t) + Q(t) = A_I(t) cos(2\\pi f t) + A_Q(t) sin(2\\pi f t) \\] åœ¨è§£ç çš„æ—¶å€™, å…ˆåˆ†åˆ«ä¹˜ä¸Šå„è‡ªçš„è½½æ³¢:\n\\[ (I(t) + Q(t)) cos(2\\pi f t) = \\frac{1}{2} (A_I(t) + A_I(t)cos(4\\pi f t) + A_Q(t)sin(4\\pi f t)) \\] \\[ (I(t) + Q(t)) sin(2\\pi f t) = \\frac{1}{2} (A_Q(t) + A_I(t)cos(4\\pi f t) - A_Q(t)sin(4\\pi f t)) \\] åœ¨è¿‡æ»¤æ‰é«˜é¢‘åˆ†é‡å:\n\\[ Filter((I(t) + Q(t)) cos(2\\pi f t)) \\approx \\frac{1}{2} A_I(t) \\] \\[ Filter((I(t) + Q(t)) sin(2\\pi f t)) \\approx \\frac{1}{2} A_Q(t) \\] å°±å¯ä»¥æˆåŠŸå¾—åˆ° \\( A_I(t) \\) å’Œ \\( A_Q(t) \\) å•¦ ğŸ‰.\nQAM ä»£ç å®ç° # ä¸ºäº†è®©å›¾æ›´å¥½çœ‹, æˆ‘ä»¬æ”¹ä¸€ä¸‹åˆå§‹è¾“å…¥å­—ç¬¦ä¸²å’Œä¿¡å™ªæ¯”:\n# Signal-to-Noise Ratio (SNR) in dB for the simulation snr = 24 # Input string to be transmitted. input_string = \u0026#34;Communications Systems Communication Channel Simulation and Report. In this project, you will complete a simulation of a wireless communication system. This builds on the tasks in Lab 1 and the lectures cover all the background theory for each part of the task.\u0026#34; # input_string = \u0026#34;a?\u0026#34; ä¸ºäº†å®ç°åŠ¨æ€QAM, æˆ‘ä»¬å¸Œæœ›å¯¹äºä¸åŒçš„ä¿¡å™ªæ¯”é€‰æ‹©ä¸åŒçš„QAMæ¨¡å‹(QAM4, QAM16 æˆ–æ˜¯ QAM64). æ­¤å¤„, å¯¹åº”äºä¸Šè¿° snr = 24, å…¶æœ¬ä¼šåŠ¨æ€é€‰æ‹© QAM64, ä½†å‡ºäºå±•ç¤ºç›®çš„, æˆ‘ä»¬å°†å…¶æ‰‹åŠ¨è°ƒæ•´ä¸º QAM16.\n# Dynamically adjust the modulation order based on the Signal-to-Noise Ratio (SNR) if snr \u0026gt;= 28: M = 64 # Use 64-QAM for high SNR, allowing more symbols (6 bits per symbol) for higher data rates elif snr \u0026gt;= 20: M = 16 # Use 16-QAM for moderate SNR, balancing data rate and noise resilience else: M = 4 # Use 4-QAM (QPSK) for low SNR, prioritizing robustness over data rate # if you do NOT want to use dynamic modulation you can use the following instruction. # Default modulation order for QAM (16-QAM) indicating 16 different symbols M = 16 M ä¸€äº›å…¶å®ƒçš„è¡ç”Ÿé‡, ä¸ºäº†æ–¹ä¾¿åé¢çš„è®¡ç®—.\nsqrt_M = int(sqrt(M)) size_symbol = int(log2(M)) n_symbol = int(len(input_string) * (8 / size_symbol)) # number of QAM symbols to create size_symbol, n_symbol å¯¹äº QAM16 å’Œ æŒ‡å®šçš„å‘é€ä¿¡æ¯, size_symbol = 4, n_symbol = 522. å‰è€…è¡¨ç¤ºå…¶â€ä¸€å£æ°”â€œæœ€å¤šå¯ä»¥ä¼ 4bit, ä¹Ÿå°±æ˜¯ä¸€ä¸ª symbol, åè€…è¡¨ç¤ºå¯¹äºç»™å®šçš„ä¿¡æ¯, å®ƒéœ€è¦ä¼  522 symbol.\nç„¶åæ˜¯ä¸¤ä¸ªè½½æ³¢:\n# Define carrier signal parameters f_s = 10000 # Sampling frequency in MHz rep_symbol = 500 # Number of samples used to represent a single QAM symbol max_t = rep_symbol * n_symbol / f_s # Total time duration of the signal print(max_t) t = np.linspace(0, max_t, int(f_s * max_t)) # Generate the time vector for the signal f_c = 100 # Carrier frequency in MHz A_c = 1 # Amplitude of the carrier # Generate the in-phase (I) and quadrature (Q) carrier signals carrier_I = A_c*np.cos(2*np.pi*f_c*t) carrier_Q = A_c*np.sin(2*np.pi*f_c*t) plt.plot(t, carrier_I) plt.xlim(left=0, right=1) è¾“å‡º:\n26.3\nå›¾4: QAM è½½æ³¢ ä»£ç ä¸­æˆ‘ä»¬å¯ä»¥å‘ç°ä¸€ä¸ªå˜é‡ rep_symbol, å®ƒåœ¨ä¸‹åˆ—çš„ä»£ç ä¸­è¢«ç”¨æ¥â€œé‡å¤â€è¾“å…¥æ•°ç»„, å·²å°†å…¶æ‰©å±•ä¸ºæ—¶é—´åºåˆ—, ä»¥æ­¤æ–¹ä¾¿åé¢ç”»å›¾æ—¶æ›´å‡†ç¡®çš„é‡‡æ ·. è€Œf_s æ­£æ˜¯åœ¨è¯è¿™ä¸ªå›¾æ˜¯çš„é‡‡æ ·é¢‘ç‡.\n# Reshape the noisy input into blocks corresponding to QAM symbols input_QAM = input_b_noise.reshape((-1,size_symbol)) print(input_QAM.shape) # Initialize arrays for amplitude components of in-phase (I) and quadrature (Q) A_I = zeros((input_QAM.shape[0],)) A_Q = zeros((input_QAM.shape[0],)) # Amplitude modulation: Calculate the amplitudes for I and Q components for n in range(int(size_symbol / 2)): A_I = A_I + input_QAM[:,n] * 2 ** (int(size_symbol / 2) - 1 - n) A_Q = A_Q + input_QAM[:,n + int(size_symbol / 2)] * 2 ** (int(size_symbol / 2) - 1 - n) # QAM # print(A_I) # print(A_Q) # Generate repeated in-phase amplitude signal to match the time resolution s_I = A_I.reshape(-1, 1).repeat(rep_symbol, 1).reshape(-1) # Modulate the in-phase component with the cosine carrier s_I_mod = s_I * carrier_I # print(s_I) # Generate repeated quadrature amplitude signal to match the time resolution s_Q = A_Q.reshape(-1, 1).repeat(rep_symbol, 1).reshape(-1) # Modulate the quadrature component with the sine carrier s_Q_mod = s_Q * carrier_Q ç„¶åæŠŠè°ƒåˆ¶åçš„ä¿¡å·ç”»å‡ºæ¥:\nplt.figure() plt.plot(t, s_I_mod) plt.plot(t, s_I, linewidth=3) plt.legend([\u0026#34;modulated I\u0026#34;, \u0026#34;I\u0026#34;]) plt.grid() plt.xlim(left=0, right=1) plt.figure() plt.plot(t, s_Q_mod) plt.plot(t, s_Q, linewidth=3) plt.legend([\u0026#34;modulated Q\u0026#34;, \u0026#34;Q\u0026#34;]) plt.grid() plt.xlim(left=0, right=1) s_mod = s_I_mod + s_Q_mod plt.figure() plt.plot(t, s_mod, linewidth=3) plt.xlim(left=0, right=1) # plt.legend([\u0026#34;modulated s\u0026#34;, \u0026#34;s\u0026#34;]) plt.grid() è¾“å‡º:\nå›¾5: QAM è°ƒåˆ¶åçš„ I åˆ†é‡ä¿¡å· å›¾6: QAM è°ƒåˆ¶åçš„ Q åˆ†é‡ä¿¡å· å›¾7: QAM è°ƒåˆ¶åçš„æ€»ä¿¡å· QAM æ˜Ÿåº§å›¾ # ä¸ºäº†ç»˜åˆ¶æ˜Ÿåº§å›¾, æˆ‘ä»¬æœ‰å¦‚ä¸‹å˜é‡å’Œå‡½æ•°:\n# Generate a normalized QAM constellation by representing points in binary format # For example, QAM16: 00, 01, 10, 11 norm_constallation = [bin(x)[2:].zfill(size_symbol // 2) for x in arange(sqrt_M)] norm_constallation def plot_constellation(S, color=\u0026#34;blue\u0026#34;, label=\u0026#39;\u0026#39;): \u0026#34;\u0026#34;\u0026#34; Plots the QAM constellation diagram, showing signal points and the grid of possible symbols. \u0026#34;\u0026#34;\u0026#34; # Separate the real and imaginary parts of the symbols for plotting sx,sy = np.real(S), np.imag(S) # Map to constellation coord k = 2 b = -(sqrt_M - 1) sx = [k * x + b for x in sx] sy = [k * y + b for y in sy] # Plot the symbols as scatter points if label: plt.scatter(sx,sy,s=30, c=color, label=label) else: plt.scatter(sx,sy,s=30, c=color) # Overlay the QAM grid points and annotate them with their binary representations for i, x in enumerate(range(-sqrt_M + 1, sqrt_M, 2)): for j, y in enumerate(range(-sqrt_M + 1, sqrt_M, 2)): plt.scatter(x, y, s=60, c=\u0026#34;r\u0026#34;) plt.annotate(f\u0026#34;{norm_constallation[i]}{norm_constallation[j]}\u0026#34;, xy=(x-0.25, y-0.5)) axis_limit = sqrt_M plt.axis([-axis_limit,axis_limit,-axis_limit,axis_limit]) plt.axhline(0, color=\u0026#39;black\u0026#39;) plt.axvline(0, color=\u0026#39;black\u0026#39;) plt.grid(True) # draw constellation S = A_I + 1j * A_Q print(S[:10]) plot_constellation(S) è¾“å‡º:\n[1.88111148+2.08807572j 3.01975263+0.01366766j 2.05328757+1.12644641j 1.83682459+3.0908774j 2.00044805+2.97572787j 2.9585253 +0.84307519j 1.92937708+3.06050133j 1.07733372+1.0006585j 2.98315354+0.84013525j 2.08884394+1.86715759j]\nå›¾8: QAM16 æ˜Ÿåº§å›¾(å‘é€å‰) è·¯å¾„æŸå¤±æ¨¡æ‹Ÿ Hata Model # # Hata Model for small or medium-sized city. #f_c: in MHz h_b = 30 # height of BS antenna in metres h_m = 2 # height of mobile antenna in matres distance = np.array([1, 2, 3, 4, 5]); #in km C_H = 0.8 + (1.1 * np.log10(f_c) - 0.7) * h_m - 1.56 * np.log10(f_c) L_U = 69.55 + 26.16 * np.log10(f_c) - 13.82 * np.log10(h_b) - C_H + (44.9-6.55*np.log10(h_b))*np.log10(distance) plt.plot(distance, L_U) plt.xlabel(\u0026#39;Distance from transmitter(in km)\u0026#39;) plt.ylabel(\u0026#39;Path loss (in dB)\u0026#39;) plt.grid() output:\nå›¾9: Hata model å¯ä»¥å‘ç°, è·ç¦»è¶Šè¿œ, æŸå¤±è¶Šå¤š.\nQAM è§£è°ƒ # ä¸ºäº†æ–¹ä¾¿è§£è°ƒ, æˆ‘ä»¬å…ˆå†™ä¸€ä¸ªæ»¤æ³¢å™¨å‡ºæ¥:\ndef butter_lowpass_filter(data, cutoff, fs, order): \u0026#39;\u0026#39;\u0026#39; Applies a Butterworth lowpass filter to the given data. \u0026#39;\u0026#39;\u0026#39; # Calculate the Nyquist frequency (half the sampling frequency) nyq = 0.5 * fs # Normalize the cutoff frequency to the Nyquist frequency normal_cutoff = cutoff / nyq # b, a are the filter coefficients b, a = signal.butter(order, normal_cutoff, btype=\u0026#39;low\u0026#39;, analog=False) # Apply the filter to the data using forward-backward filtering y = signal.filtfilt(b, a, data) return y QAM è§£è°ƒä»¥åŠå¯¹åº”çš„æ³¢å½¢:\n# Demodulate the in-phase (I) component # Multiply the received signal by the in-phase carrier and scale by 2 to isolate the I component s_I_demod = s_mod * carrier_I * 2 # Apply the Butterworth lowpass filter to remove high-frequency components s_I_demod = butter_lowpass_filter(s_I_demod, 50, f_s, 2) # Demodulate the quadrature (Q) component # Multiply the received signal by the quadrature carrier and scale by 2 to isolate the Q component s_Q_demod = s_mod * carrier_Q * 2 # Apply the Butterworth lowpass filter to remove high-frequency components s_Q_demod = butter_lowpass_filter(s_Q_demod, 50, f_s, 2) # Plot the modulated and demodulated in-phase components plt.figure() plt.plot(t, s_I_mod) plt.plot(t, s_I_demod) plt.xlim(left=0, right=1) plt.legend([\u0026#34;modulated I\u0026#34;, \u0026#34;demodulated I\u0026#34;]) plt.grid() # Plot the modulated and demodulated quadrature components plt.figure() plt.plot(t, s_Q_mod) plt.plot(t, s_Q_demod) plt.xlim(left=0, right=1) plt.legend([\u0026#34;modulated Q\u0026#34;, \u0026#34;demodulated Q\u0026#34;]) plt.grid() output:\nå›¾10: QAM è§£è°ƒåçš„ I åˆ†é‡ä¿¡å· å›¾11: QAM è§£è°ƒåçš„ Q åˆ†é‡ä¿¡å· å¯¹åº”çš„æ˜Ÿåº§å›¾:\n# Reshape the demodulated signal into blocks of size `rep_symbol` and calculate the average for each block A_I_demod = np.average(s_I_demod.reshape((-1, rep_symbol)), 1) A_Q_demod = np.average(s_Q_demod.reshape((-1, rep_symbol)), 1) print(s_I_demod.reshape((rep_symbol, -1)).shape) print(A_I_demod.shape) # To draw constrllation # Combined in-phase and quadrature components to form complex symbols S_demod = A_I_demod + 1j * A_Q_demod # Plot the constellation plot_constellation(S, label=\u0026#34;Transmitted\u0026#34;) plot_constellation(S_demod, color=\u0026#34;green\u0026#34;, label=\u0026#34;Received\u0026#34;) plt.legend() output:\n(500, 526) (526,) å›¾12: QAM16 æ˜Ÿåº§å›¾(è§£è°ƒå) # Round the demodulated signal\u0026#39;s amplitudes to the nearest integers A_I_demod = [int(round(x)) for x in A_I_demod] A_Q_demod = [int(round(x)) for x in A_Q_demod] # Map the rounded amplitudes to their corresponding binary strings in the normalized constellation output_b = [norm_constallation[min(len(norm_constallation) - 1, int(x))] + norm_constallation[min(len(norm_constallation) - 1, int(y))] for x, y in zip(A_I_demod, A_Q_demod)] # Concatenate all binary strings into a single bitstream output_b = \u0026#39;\u0026#39;.join(output_b) # Decode the bitstream using a Hamming decode function output_b = list(decode(bitarray(output_b))) output_b_int_list = output_b # Convert each binary value in the list to a string for easier manipulation output_b = [str(x) for x in output_b] # Group the binary strings into bytes (8 bits each) for interpretation output_b = [\u0026#39;\u0026#39;.join(output_b[8*i : 8*i + 8]) for i in range(len(output_b) // 8)] print(output_b[:10]) # Convert the grouped binary values back into the original string output_string = bits2string(output_b) print(output_string) output:\n[\u0026#39;01000011\u0026#39;, \u0026#39;01101111\u0026#39;, \u0026#39;01101101\u0026#39;, \u0026#39;01101101\u0026#39;, \u0026#39;01110101\u0026#39;, \u0026#39;01101110\u0026#39;, \u0026#39;01101001\u0026#39;, \u0026#39;01100011\u0026#39;, \u0026#39;01100001\u0026#39;, \u0026#39;01110100\u0026#39;] Communications Systems Communication Channel Simulation and Report. In this project, you will complete a simulation of a wireless communication system. This builds on the tasks in Lab 1 and the lectures cover all the background theory for each part of the task. è¯¯ç ç‡ # print(output_b_int_list[:24]) print(input_b_int_list[:24]) # Initialize the Bit Error Rate (BER) counter BER = 0 # Initialize a list to store the indices of errors error_list = [] # Iterate through pairs of input and output bits (or values) for comparison for i, (input, output) in enumerate(zip(input_b_int_list, output_b_int_list)): if input != output: BER += 1 error_list += [i] # Calculate the BER by dividing the total errors by the length of the output BER /= len(output_b_int_list) print(f\u0026#34;BER is {BER}\u0026#34;) print(f\u0026#34;find error at {error_list}\u0026#34;) output:\n[0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1] [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1] BER is 0.0 find error at [] ååˆ†å®Œç¾!\n"},{"id":2,"href":"/docs/example/my-blog/pns/pns_ch2/","title":"CH2.å·¥ä¸šç”Ÿäº§æ¨¡å‹","section":"å·¥ä¸šç”Ÿäº§è§„åˆ’è°ƒåº¦é˜…è¯»ç¬”è®°","content":" Chapter 2 Manufacturing Models # 2.1 Introduction # 2.2 Jobs, Machines, and Facilities # ä¸€äº›åŸºæœ¬æ¦‚å¿µ:\nThe number of jobs is denoted by n and the number of machines by m. The subscripts j and k refer to jobs j and k. The subscripts h and i refer to machines h and i. The following data pertain to job j.\nä¹Ÿå°±æ˜¯:\njob æ•°: n. æœºå™¨æ•°: m. é™¤æ­¤å¤–, è¿˜æœ‰:\nå¤„ç†æ—¶é—´: ( pijp_{ij} ): represents the time job j has to spend on machine i. æˆªæ­¢æ—¥æœŸ ( djd_{j} ). æƒé‡ ( wjw_j ). job çš„ä¼˜å…ˆçº§ It may represent the cost of keeping job j in the system for one time unit. The weight can be a holding or inventory cost, or it can be the amount of value already added to the job.\nä»¥ä¸Š 4 ä¸ªæ•°æ®å¹¶ç§°ä¸º é™æ€æ•°æ® (static data). å› ä¸ºå®ƒä»¬ä¸ä¾èµ–äºè°ƒåº¦ç®—æ³•. ç›¸å, é‚£äº›ä¸èƒ½æå‰ç¡®å®šå¹¶ä¸”ä¾èµ–äºè°ƒåº¦ç®—æ³•çš„æ•°æ®ç§°ä¹‹ä¸º åŠ¨æ€æ•°æ® (dynamic data). æ¯”è¾ƒé‡è¦çš„åŠ¨æ€æ•°æ®å¦‚ä¸‹:\nStarting time SijS_{ij} : job j å¼€å§‹åœ¨ æœºå™¨i ä¸Šå¤„ç†çš„æ—¶é—´ç‚¹. Completion time CijC_{ij} : å®Œæˆæ—¶é—´. è°ƒåº¦æ¨¡å‹çš„ä¸€ä¸ªé‡è¦ç‰¹å¾æ˜¯å®ƒçš„ æœºå™¨é…ç½® (machine configuration), å¦‚ä¸‹:\nSingle Machine Models: job åªèƒ½å»ä¸€ä¸ªåœ°æ–¹å¤„ç† Parallel Machine Models: job å¯ä»¥é€‰æ‹©å¤šå°æœºå™¨ä¸­çš„å…¶ä¸­ä¸€ä¸ª Flow Shop Models: æ‰€æœ‰çš„ job éƒ½ä¼šç»è¿‡ç›¸åŒçš„å¤„ç† Job Shop Models: job é€šå¸¸æœ‰ä¸åŒçš„å¤„ç† Supply Chain Models a flow shop is a job shop in which each and every job has the same route\n2.3 Processing Characteristics and Constraints # job çš„å¤„ç†ä¹Ÿæœ‰ç‰¹å¾å’Œå¯¹åº”çš„é™åˆ¶.\nPrecedence Constraints: å‰åé™åˆ¶, ä¸€ä¸ª job å¿…é¡»å®Œæˆä¸€ä¸ªå¤„ç†ä¸ªå†è¿›è¡Œä¸‹ä¸€ä¸ªå¤„ç†. Machine Eligibility Constraints: å½“æœºå™¨ä¸å®Œå…¨ä¸€æ ·æ—¶, æœ‰äº›æœºå™¨å¯èƒ½æ²¡æœ‰èµ„æ ¼å®Œæˆå¯¹ç‰¹ç‚¹ job çš„å¤„ç†. Workforce Constraints. Routing Constraints. Material Handling Constraints. Sequence Dependent Setup Times and Costs. Storage Space and Waiting Time Constraints. Make-to-Stockand Make-to-Order. Preemptions. Transportation Constraints. 2.4 Performance Measures and Objectives # ä¸€äº›å…³é”®çš„æè¿°æ€§èƒ½çš„ æµ‹é‡å€¼ å’Œ ç›®æ ‡:\nThroughput and Makespan Objectives. Throughput = output rate Makespan = æ‰€æœ‰å·¥ä½œå…¨éƒ¨å®Œæˆæ‰€éœ€çš„æ€»æ—¶é—´ Cmax=max(C1,...,Cn)Cmax = max(C_1,...,C_n) Due Date Related Objectives. one objective: minimizing the maximum lateness Lateness: Lj=Cjâˆ’djL_j= C_jâˆ’d_j Lmax=max(L1,...,Ln) L_{max} = max(L_1,...,L_n) anather objective: minimizing number of tardy jobs tardiness of job j: Tj=max(Cjâˆ’dj,0)T_j = max(C_jâˆ’d_j,0) âˆ‘j=1nÏ‰jTj\\sum^n_{j=1}\\omega_jT_j Setup Costs. Work-In-Process Inventory Costs. (WIP) Finished Goods Inventory Costs. Transportation Costs. "},{"id":3,"href":"/docs/example/my-blog/pns/pns_ch4/","title":"CH4.é¡¹ç›®çš„è§„åˆ’è°ƒåº¦","section":"å·¥ä¸šç”Ÿäº§è§„åˆ’è°ƒåº¦é˜…è¯»ç¬”è®°","content":" Chapter 4 Project Planning and Scheduling # 4.1 Introduction # æœ¬ç« çš„ä¸€äº›å‰æ:\nThis chapter focuses on the planning and scheduling of jobs that are subject to precedence constraints. The setting may be regarded as a parallel machine environment with an unlimited number of machines.\næˆ‘ä»¬çš„ä¼˜åŒ–ç›®æ ‡:\nThe objective is to minimize the makespan while adhering to the precedence constraints\nä¸¤ä¸ªé™åˆ¶:\nprecedence constraints: æ¯ä¸ª job çš„å¼€å§‹éœ€è¦ç­‰å¾…ä¸Šä¸€ä¸ª job çš„å®Œæˆ. workforce constraints: æ“ä½œå‘˜å¯èƒ½çŸ­ç¼º (å¿™ä¸è¿‡æ¥) job å…ˆåé¡ºåºè¡¨ç¤ºçš„ä¸¤ç§æ–¹å¼: å¯¹äºå‰ä¸€ç§, æ¯ä¸ª arc ä»£è¡¨ job, æ¯ä¸ª node ä»£è¡¨ä¸€ä¸ª epoch. å¯¹äºåä¸€ç§, æ¯ä¸ª node ä»£è¡¨ job, æ¯ä¸ª arc ä»£è¡¨ å…ˆåå…³ç³».\n4.2 Critical Path Method (CPM) # é¦–å…ˆå£°æ˜å¿…è¦çš„ assumptions:\nThe processing time of job j is fixed and equal to $p_j$. unlimited number of machines in parallel. Besides a machine (and there is always one available) a job does not require any other resource. åœ¨æ­¤å‰æä¸‹, è¿™ä¸ªæ–¹æ³•å¯ä»¥è¿™æ ·æè¿°:\nStart at time zero with the processing of all jobs that have no predecessors. Every time a job completes its processing, start processing those jobs of which all the predecessors have been completed.\nä¹Ÿå°±æ˜¯è¯´, ä¸€ä¸ªä¸€ä¸ªæŒ‰é¡ºåºåš.\nä½†æ˜¯ä¸ºäº†æ›´åŠ æ­£å¼çš„æè¿°è¿™ä¸ªç®—æ³•, æˆ‘ä»¬éœ€è¦å¼•å…¥ä»¥ä¸‹ç¬¦å·:\nCjâ€²C\u0026#x27;_j : job j çš„æœ€æ—©å¯èƒ½å®Œæˆæ—¶é—´. Sjâ€²S\u0026#x27;_j : job j çš„æœ€æ—©å¯èƒ½å¼€å§‹æ—¶é—´. pjp_j : job j æ‰€éœ€è¦çš„å¤„ç†æ—¶é—´. {all k -\u0026gt; j}: job j çš„å…¨éƒ¨å‰ç½®. å› æ­¤, æˆ‘ä»¬å¯ä»¥æ‹¥æœ‰ä»¥ä¸‹ä¼ªä»£ç :\nè¿™ä¸ªæ–¹æ³•, æˆ‘ä»¬ç§°ä¹‹ä¸º Forward Procedure. ç„¶è€Œ, å®ƒè™½ç„¶ç®€å•æ˜“æ‡‚, ä½†æ˜¯å®ƒå¹¶ä¸ä¸€å®šèƒ½å¸¦æ¥æœ€ä¼˜çš„æ•ˆç‡. å› ä¸ºå®ƒæœ‰å¯èƒ½å»¶è¿ŸæŸäº› job çš„å¼€å§‹.\nå› æ­¤, æˆ‘ä»¬æ¥ä¸‹æ¥è¦ä»‹ç»å¦ä¸€ä¸ª CPM ç®—æ³•: Backward Procedure. è¿™ä¸ªç®—æ³•åˆ©ç”¨äº† Forward Procedure çš„è¾“å‡º $C_max$ ä½œä¸ºè¾“å…¥, ç„¶åå…¶å®ƒéœ€è¦å®šä¹‰çš„ç¬¦å·å¦‚ä¸‹:\nCjâ€²â€²C^{\\prime\\prime}_j : job j æœ€æ™šå¯èƒ½å®Œæˆæ—¶é—´. Sjâ€²â€²S^{\\prime\\prime}_j : job j æœ€æ™šå¯èƒ½å¼€å§‹æ—¶é—´. {j -\u0026gt; all k}: job j çš„å…¨éƒ¨åç½®. So the forward procedure determines the earliest possible starting time and completion times as well as the minimum makespan.\nåé¢åˆè¡¥å……äº†å‡ ä¸ªæ¦‚å¿µ:\nThe diï¬€erence between a jobâ€™s latest possible starting time and earliest possible starting time is the amount of slack, also referred to as float. A job of which the earliest starting time is equal to the latest starting time is referred to as a critical job. The set of critical jobs forms one or more critical paths. A critical path is a chain of non-slack jobs. 4.3 Program Evaluation and Review Technique (PERT) # 4.4 Time/Cost Trade-Oï¬€s: Linear Costs # 4.5 Time/Cost Trade-Oï¬€s: Nonlinear Costs # 4.6 Project Scheduling with Workforce Constraints # 4.7 ROMAN: A Project Scheduling System for the Nuclear Power Industry # 4.8 Discussion # "},{"id":4,"href":"/docs/example/my-blog/navigation/navi_l2/","title":"L2.å¯¼èˆªæ•°å­¦åŸºç¡€","section":"å¯¼èˆª","content":" The Mathematics of Navigation # Coordinate Systems # ä¸ºäº†å®ç° navigation position fix, æˆ‘ä»¬éœ€è¦å…ˆç¡®å®šä¸€ä¸ªå‚è€ƒç³» (frame-of-reference), F\\mathscr{F} .\nä¸€ä¸ªç›´è§’åæ ‡ç³» (Cartesian coordinate frame) åŒ…å«äº†ä¸‰ä¸ªç›¸äº’æ­£äº¤ (mutually-orthogonal) çš„åŸºå‘é‡ (x,y,z)(x, y, z) .\nä¾‹å¦‚:\nè¿™ä¸ªå›¾ä¸­, pp åœ¨åæ ‡ç³» FÎ²\\mathscr{F^{\\beta}} ä¸­, å› æ­¤æˆ‘ä»¬å¯ä»¥æŠŠå…¶è®°ä½œ pÎ²â€¾\\underline{p^{\\beta}} .\nå…¶ä¸­, ä¸‹åˆ’çº¿è¡¨ç¤ºå…¶æ˜¯ä¸€ä¸ªçŸ¢é‡, ä¸Šæ ‡ Î²\\beta è¡¨ç¤ºå…¶æ˜¯åœ¨ FÎ²\\mathscr{F^{\\beta}} è¿›è¡Œçš„æµ‹é‡.\nNavigation Frames # æ¥ä¸‹æ¥, æˆ‘ä»¬éœ€è¦å®šä¹‰å‡ ä¸ªå¸¸ç”¨çš„å‚è€ƒç³»ç”¨äºå¯¼èˆª.\nEarth Centred Inertial # åœ°å¿ƒæƒ¯æ€§åæ ‡ç³» (Earth-Centered Inertial), ç®€ç§° ECI, å¸¸ç”¨ ii è¡¨ç¤º.\nAn inertial coordinate frame is one that does not accelerate or rotate with respect to the rest of the Universe.\nECI åæ ‡ç³» Fi\\mathscr{F^i} çš„åŸç‚¹å¤„äºåœ°çƒçƒå¿ƒ OeO_e . å…¶ z è½´æŒ‡å‘åŒ—æ, x, yè½´ å¤„äºèµ¤é“å¹³é¢, ä½†æ˜¯ä¸å’Œåœ°çƒä¸€èµ·æ—‹è½¬. å…¶ä¸­, x è½´åœ¨æ˜¥åˆ†æ—¶æ­£å¥½æŒ‡å‘å¤ªé˜³, y è½´è´Ÿè´£æ»¡è¶³ RHS (right-handed set).\nEarth Centred - Earth Fixed # åœ°å¿ƒå›ºå®šåæ ‡ç³» (Earth Centred, Earth Fixed), ç®€ç§° ECEF, å¸¸ç”¨ ee è¡¨ç¤º.\nECEF åæ ‡ç³» ( Fe\\mathscr{F^e} ) ä¹Ÿæ˜¯ä»¥åœ°çƒçƒå¿ƒä¸ºåŸç‚¹, ä½†æ˜¯å®ƒçš„è½´æ˜¯å›ºå®šåœ¨åœ°çƒä¸Šçš„. å…·ä½“æ¥è¯´, z è½´æŒ‡å‘åŒ—æ, x è½´æŒ‡å‘æ ¼æ—å¨æ²»å­åˆçº¿ (Greenwich merdian) ä¸èµ¤é“å¹³é¢çš„äº¤ç‚¹, y è½´è´Ÿè´£æ»¡è¶³ RHS.\nECEF åæ ‡ç³»ç›¸å¯¹äº ECI è¿™ä¸ªæƒ¯æ€§ç³» ä»¥ Î©ie\\Omega_{ie} ç»•ç€ OziOz^i è½´æ—‹è½¬.\nLocal Navigation Frame # æœ¬åœ°å¯¼èˆªåæ ‡ç³» (Local Navigation Frame), ç®€ç§° NED, è®°ä½œ nn (native ??), i.e. Fn\\mathscr{F^n} .\nå…¶åŸç‚¹å›ºå®šåœ¨éœ€è¦çš„åœ°æ–¹, x è½´æœåŒ— (N), y è½´æœä¸œ (E), z è½´æœä¸‹ (Down). æ‰€ä»¥å«å®ƒ NED.\nVehicle (body) Frame # å¯¹è±¡å‚è€ƒç³», å’Œ NED å‚è€ƒç³»å¾ˆç›¸ä¼¼, ä½†æ˜¯è¿™ä¸ªå‚è€ƒç³»çš„å§¿æ€ (attitude) ä¼šéšç€æ—¶é—´å˜æ¢.\nMathematical Notation # ç°åœ¨, æˆ‘ä»¬éœ€è¦æ›´è¯¦ç»†çš„å®šä¹‰ä¸€ä¸‹åæ ‡ç³»:\nxâ€¾Î²Î±Î³\\underline{x}^{\\gamma}_{\\beta\\alpha} å…¶ä¸­:\nÎ±\\alpha æ˜¯ å¯¹è±¡ç³» (object frame) Î²\\beta æ˜¯ å‚è€ƒç³» (reference frame) Î³\\gamma æ˜¯ è§£æç³» (resolving frame) ä¾‹å¦‚:\nThe red vector shows the position of FÎ±\\mathscr{F}^{\\alpha} wrt FÎ²\\mathscr{F}^{\\beta} . The black dotted lines show the coordinates of râ€¾Î²Î±Î²\\underline{r}^{\\beta}_{\\beta\\alpha} and the blue dotted lines râ€¾Î²Î±Î±\\underline{r}^{\\alpha}_{\\beta\\alpha} .\nTransforming Between Coordinate Frames # Coordinate Transformation Matrix # è¿™é‡Œçš„çŸ©é˜µç§°ä¹‹ä¸º æ–¹å‘ä½™å¼¦çŸ©é˜µ (Direction Cosine), å…¶æ˜¯å›´ç»•ç€ zÎ²z^{\\beta} è½´è¿›è¡Œçš„æ—‹è½¬.\nè¿™æ ·çš„æ—‹è½¬çŸ©é˜µæ˜¯åæ ‡å˜æ¢çŸ©é˜µçš„ä¸€ç§, è®°ä½œ CÎ²Î³C^{\\gamma}_{\\beta} . ä¸‹æ ‡ Î²\\beta è¡¨ç¤º from, ä¸Šæ ‡ Î±\\alpha è¡¨ç¤º to. è¿™ç‚¹ä¸å‰é¢çš„æ ‡è®°ä¸å¤ªä¸€è‡´.\næˆ‘ä»¬å¯ä»¥è¿™æ ·ä½¿ç”¨è¿™ä¸ªçŸ©é˜µ:\nxâ€¾Î´Î³Î±=CÎ²Î±xâ€¾Î´Î³Î²\\underline{x}^{\\alpha}_{\\delta\\gamma} = C^{\\alpha}_{\\beta}\\underline{x}^{\\beta}_{\\delta\\gamma} è¿™ä¸ªæ–¹å‘ä½™å¼¦çŸ©é˜µæœ‰ä»¥ä¸‹æ€§è´¨:\næ­£äº¤ (orthogonal) CÎ²Î±=(CÎ±Î²)âˆ’1=(CÎ±Î²)TC^{\\alpha}_{\\beta} = (C^{\\beta}_{\\alpha})^{-1} = (C^{\\beta}_{\\alpha})^T å¯ç›¸ä¹˜ CÎ²Î³=CÎ±Î³CÎ²Î±C^{\\gamma}_{\\beta} = C^{\\gamma}_{\\alpha}C^{\\alpha}_{\\beta} Euler Angles # ä¸ºäº†å®šä¹‰ç»å¯¹çš„å§¿æ€, æˆ‘ä»¬éœ€è¦æ¬§æ‹‰è§’ (Euler angle).\nç„¶å, æ•´ä¸ªå®Œæ•´çš„åæ ‡ç³»å˜æ¢å¯ä»¥åˆ†æˆä»¥ä¸‹ä¸‰ä¸ªéƒ¨åˆ†:\nYAW ( Ïˆ\\psi ), å›´ç»•åˆå§‹çš„ z è½´æ—‹è½¬. PITCH ( Î¸\\theta ), å›´ç»•ç¬¬ä¸€æ­¥æ—‹è½¬å®Œæˆåçš„ y è½´æ—‹è½¬. ROLL ( Ï•\\phi ), å›´ç»•ç¬¬äºŒæ­¥æ—‹è½¬å®Œæˆåçš„ x è½´æ—‹è½¬ ä»¥åŠæ¯ä¸€æ­¥å¯¹åº”çš„å˜æ¢çŸ©é˜µ: æœ€ç»ˆçš„ Euler Direction Cosine matrix ( CÎ²Î±=Câ€²â€²Î±Câ€²â€²â€²CÎ²â€²C^{\\alpha}_{\\beta} = C^{\\alpha}_{\\prime\\prime}C^{\\prime\\prime}_{\\prime}C^{\\prime}_{\\beta} ):\nCartesian Coordinates # Velocity # å‚è€ƒç³» FÎ±\\mathscr{F}^{\\alpha} å¯¹äº å‚è€ƒç³» FÎ²\\mathscr{F}^{\\beta} çš„é€Ÿåº¦, åœ¨ FÎ³\\mathscr{F}^{\\gamma} ä¸‹çš„è§£æè§£æ˜¯:\nvâ€¾Î²Î±Î³=CÎ²Î³râ€¾Ë™Î²Î±Î²\\underline{v}^{\\gamma}_{\\beta\\alpha} = C^{\\gamma}_{\\beta}\\dot{\\underline{r}}^{\\beta}_{\\beta\\alpha} æ³¨æ„: è¿™ä¸ªå’Œç›´æ¥å¯¹ râ€¾Î²Î±Î³\\underline{r}^{\\gamma}_{\\beta\\alpha} å…³äºæ—¶é—´æ±‚å¯¼çš„ç»“æœä¸ä¸€æ ·. è¿™æ˜¯å› ä¸º, å½“å­˜åœ¨åæ ‡ç³»ä¹‹é—´çš„æ—‹è½¬æ—¶, æˆ‘ä»¬æœ‰:\nrË™â€¾Î²Î±Î³=CË™Î²Î³râ€¾Î²Î±Î²+CÎ²Î³rË™â€¾Î²Î±Î²=CË™Î²Î³râ€¾Î²Î±Î²+vâ€¾Î²Î±Î³\\underline{\\dot{r}}^{\\gamma}_{\\beta\\alpha} = \\dot{C}^{\\gamma}_{\\beta}\\underline{r}^{\\beta}_{\\beta\\alpha} + C^{\\gamma}_{\\beta}\\underline{\\dot{r}}^{\\beta}_{\\beta\\alpha} = \\dot{C}^{\\gamma}_{\\beta}\\underline{r}^{\\beta}_{\\beta\\alpha} + \\underline{v}^{\\gamma}_{\\beta\\alpha} ä¸€ä¸ªé‡è¦ç»“è®º: å¦‚æœ è§£æç³» å’Œ å‚è€ƒç³» æœ‰æ—‹è½¬, é‚£ä¹ˆå¯¹ æ—¶é—´æ±‚å¯¼ ä¸èƒ½ç›´æ¥ç­‰äºé€Ÿåº¦/åŠ é€Ÿåº¦.\nAngular Velocity # è§’é€Ÿåº¦ Ï‰â€¾Î²Î±Î³\\underline{\\omega}^{\\gamma}_{\\beta\\alpha} æ˜¯ å‚è€ƒç³» FÎ±\\mathscr{F}^{\\alpha} ç›¸å¯¹äºåæ ‡ç³» FÎ²\\mathscr{F}^{\\beta} çš„æ—‹è½¬é€Ÿåº¦, åœ¨åæ ‡ç³» FÎ³\\mathscr{F}^{\\gamma} ä¸‹è§£æ.\nå…¶å¯è¡¨ç¤ºä¸º:\nÏ‰â€¾Î²Î±Î³=(pÎ²Î±Î³,qÎ²Î±Î³,rÎ²Î±Î³)\\underline{\\omega}^{\\gamma}_{\\beta\\alpha} = (p^{\\gamma}_{\\beta\\alpha}, q^{\\gamma}_{\\beta\\alpha}, r^{\\gamma}_{\\beta\\alpha}) å¦ä¸€ä¸ªå¸¸è§çš„è¡¨è¾¾å½¢å¼æ˜¯åå¯¹ç§°çŸ©é˜µ (skew-symmetric matrix):\nä¸è¿™ä¸ªçŸ©é˜µç›¸ä¹˜, ç­‰æ•ˆäºä¸ Ï‰â€¾Î²Î±Î³\\underline{\\omega}^{\\gamma}_{\\beta\\alpha} åšå‰ä¹˜.\nTransformation of Matrix # é‚£ä¹ˆ, ç»“ä¸‹æ¥æˆ‘ä»¬å¯ä»¥æ¥æ€è€ƒä¸€ä¸‹å¦‚ä½•å˜æ¢ å˜æ¢çŸ©é˜µ çš„è§£æç³» (å¥½åƒæœ‰ç‚¹ç‚¹ç»•\u0026hellip;).\nç”±äºè¿™é‡Œå˜æ¢çš„æ˜¯çŸ©é˜µ, è¿™ç‚¹ä¸å‰é¢çš„å‘é‡ä¸å¤ªä¸€æ ·, æ‰€ä»¥æˆ‘ä»¬éœ€è¦é‡æ–°æ¨å¯¼:\nStrapdown Equation # åœ¨æˆ‘ä»¬å®šä¹‰äº†è§’é€Ÿåº¦å, ç°åœ¨æˆ‘ä»¬å¯ä»¥å¼€å§‹å®šä¹‰ CË™Î²Î³\\dot{C}^{\\gamma}_{\\beta} .\nå› æ­¤, æˆ‘ä»¬å¯ä»¥å¾—åˆ° æ·è”æ–¹ç¨‹ (Strapdown Equation):\nCË™Î²Î³(t)=âˆ’Î©Î²Î³Î³CÎ²Î³\\dot{C}^{\\gamma}_{\\beta}(t) = - \\Omega^{\\gamma}_{\\beta\\gamma}C^{\\gamma}_{\\beta} CË™Î³Î²(t)=CÎ³Î²Î©Î²Î³Î³\\dot{C}^{\\beta}_{\\gamma}(t) = C^{\\beta}_{\\gamma}\\Omega^{\\gamma}_{\\beta\\gamma} å…¶ä»–çš„å‡ ç§å½¢å¼:\nAcceleration # åŠ é€Ÿåº¦çš„å®šä¹‰å°±æ˜¯å¯¹äºä½ç½®çš„äºŒé˜¶å¯¼.\nå½“ç„¶, åœ¨å˜æ¢åŠ é€Ÿçš„è§£æç³»æ—¶, æˆ‘ä»¬ä¹Ÿä¼šé‡åˆ°ç›¸åŒçš„éš¾é¢˜:\nå…¶ä¸­,\nCÎ²Î³Â¨\\ddot{C^{\\gamma}_{\\beta}} râ€¾Ë™Î²Î±Î²\\dot{\\underline{r}}^{\\beta}_{\\beta\\alpha} éƒ½æ˜¯å¾…ç»­è§£å†³çš„é—®é¢˜.\nå¯¹äºç¬¬ä¸€ä¸ª:\nå¯¹äºç¬¬äºŒä¸ª:\nä»£å…¥åå¯ä»¥å¾—åˆ°:\nEarth Surface and Gravity Models # Earth Surface Model # Gravity Models # é‡åŠ›æ¨¡å‹ (Gravity Models) æœ‰ä¸¤ä¸ªå…³é”®çš„åˆ†é‡:\næ¯”åŠ› (Specific Force) fâ€¾ibÎ³\\underline{f}^{\\gamma}_{ib} : å•ä½è´¨é‡å—åˆ°çš„éä¸‡æœ‰å¼•åŠ›çš„åŠ›. ä¸‡æœ‰å¼•åŠ› (Gravitation) Î³â€¾ibÎ³\\underline{\\gamma}^{\\gamma}_{ib} : å¯¹äºå•ä½è´¨é‡çš„ä¸‡æœ‰å¼•åŠ›. ps: Gravitation æŒ‡çš„æ˜¯çº¯ç²¹çš„ä¸‡æœ‰å¼•åŠ›ï¼Œä¸åŒ…å«ç”±äºåœ°çƒè‡ªè½¬äº§ç”Ÿçš„å‘å¿ƒåŠ é€Ÿåº¦ã€‚\nå› æ­¤æˆ‘ä»¬æœ‰:\nfâ€¾ibÎ³=aâ€¾ibÎ³âˆ’Î³â€¾ibÎ³ \\underline{f}^{\\gamma}_{ib} = \\underline{a}^{\\gamma}_{ib} - \\underline{\\gamma}^{\\gamma}_{ib} åœ¨å®é™…ä½¿ç”¨è¿™ä¸ªæ–¹ç¨‹æ—¶, æˆ‘ä»¬ä¼šå‘ç°, ç”±äºä¼ æ„Ÿå™¨æ˜¯å›ºå®šåœ¨ body ä¸Šçš„, æ‰€ä»¥æˆ‘ä»¬æµ‹é‡çš„æ¯”åŠ›æ˜¯ fâ€¾ibb\\underline{f}^{b}_{ib} .\nå†æœ‰,\naâ€¾ibe=Î©â€¾ibeÎ©â€¾iberâ€¾ibe+2Î©â€¾ibevâ€¾ibe+aâ€¾ibe\\underline{a}^{e}_{ib} = \\underline{\\Omega}^{e}_{ib}\\underline{\\Omega}^{e}_{ib}\\underline{r}^{e}_{ib} + 2\\underline{\\Omega}^{e}_{ib}\\underline{v}^{e}_{ib} + \\underline{a}^{e}_{ib} ps: æˆ‘ä»¬ä¸è€ƒè™‘åœ°çƒçš„è‡ªè½¬åŠ é€Ÿåº¦.\nå½“ç‰©ä½“åœ¨åœ°çƒä¸Šé™æ­¢ä¸åŠ¨æ—¶, æˆ‘ä»¬æœ‰:\naâ€¾ibe=Î©â€¾ibeÎ©â€¾iberâ€¾ibe\\underline{a}^{e}_{ib} = \\underline{\\Omega}^{e}_{ib}\\underline{\\Omega}^{e}_{ib}\\underline{r}^{e}_{ib} ä»£å…¥å¯å¾—:\nfâ€¾ibÎ³=Î©â€¾ibeÎ©â€¾iberâ€¾ibeâˆ’Î³â€¾ibÎ³ \\underline{f}^{\\gamma}_{ib} = \\underline{\\Omega}^{e}_{ib}\\underline{\\Omega}^{e}_{ib}\\underline{r}^{e}_{ib} - \\underline{\\gamma}^{\\gamma}_{ib} ç”±äºæˆ‘ä»¬è®¤ä¸ºåœ¨ ECEF ç³»ä¸­, è¯¥ç‰©ä½“åªå—åˆ° é‡åŠ› (Gravity) å’Œ éé‡åŠ›å¤–åŠ›, æˆ‘ä»¬æœ‰:\ngâ€¾be=âˆ’fâ€¾ibe=Î³â€¾ibÎ³âˆ’Î©â€¾ibeÎ©â€¾iberâ€¾ibe \\underline{g}^{e}_{b} = -\\underline{f}^{e}_{ib} = \\underline{\\gamma}^{\\gamma}_{ib} - \\underline{\\Omega}^{e}_{ib}\\underline{\\Omega}^{e}_{ib}\\underline{r}^{e}_{ib} æˆ‘ä»¬å› æ­¤å¾—åˆ°äº†é‡åŠ›.\nNavigation Frames and Transposition # "},{"id":5,"href":"/docs/example/my-blog/navigation/navi_l3/","title":"L3.æƒ¯æ€§å¯¼èˆª","section":"å¯¼èˆª","content":" Inertial Navigation # Mechanisation of Inertial Navigation Systems # æƒ¯æ€§å¯¼èˆªæ˜¯ä¸€ç§èˆªä½æ¨æµ‹æ³• (dead reckoning). å¦‚æœæˆ‘ä»¬çŸ¥é“ä¸€ä¸ªç‰©ä½“çš„åŠ é€Ÿåº¦, é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ä¸€æ¬¡ç§¯åˆ†è·å¾—å…¶é€Ÿåº¦ä¿®æ­£, ä¸¤æ¬¡ç§¯åˆ†ä»¥è·å¾—å…¶ä½ç½®.\nä¸è¿‡, æ­£å¦‚ä¸Šä¸€èŠ‚æ‰€çœ‹åˆ°çš„, å¦‚æœå‚è€ƒç³»å’Œè§£æç³»ä¸æ˜¯åŒä¸€ä¸ªç³», é‚£ä¹ˆå°±è¦è€—è´¹å¤§é‡çš„è¿ç®—èµ„æºå»æ±‚è§£.\nåœ¨è¿‡å», ç”±äºç®—åŠ›æœ‰é™, äººä»¬éœ€è¦ä½¿ç”¨ Stabilised Inertial Platform.\nè€Œç°åœ¨, ç”±äºç®—åŠ›ä¸æ˜¯å¤§é—®é¢˜äº†, äººä»¬ç›´æ¥è®²ä¼ æ„Ÿå™¨å›ºå®šåœ¨å¯¹è±¡ä¸Š, ä¹Ÿå°±æ˜¯ä½¿ç”¨ Strapdown INS configuration.\nStabilised Inertial Platform # ç¨³å®šæƒ¯æ€§å¹³å° (Stabilised Inertial Platform) å¤§è‡´å¦‚ä¸‹:\né‡Œé¢çš„é™€èºä»ª (gyro) ä¼šæµ‹é‡å¹³å°è½¬åˆ°çš„è§’åº¦. è€Œè¿™äº›æµ‹é‡çš„è§’åº¦åˆä¼šè¢«å½“æˆåé¦ˆä¿¡å·ä¼ é€’ç»™è½´ä¸Šçš„é©¬è¾¾, æ¥è°ƒæ•´å§¿æ€.\nç„¶è€Œ, å®ƒæœ‰å¦‚ä¸‹ç¼ºç‚¹:\nmechanically complex costly to manufacture/maintain larger volume/weight cannot be used directly for airframe stabilisation Strapdown System # å› æ­¤, å¯¹äºæ–°çš„ INS ç³»ç»Ÿ, äººä»¬é€šå¸¸å–œæ¬¢ä½¿ç”¨ Strapdown Configuration.\nä¸ Stablised Inertial Platform ä¸ä¸€æ ·, å®ƒçš„ gyro æ˜¯ç›´æ¥å›ºå®šåœ¨æµ‹é‡å¯¹è±¡ä¸Šçš„. ä¹Ÿå°±æ˜¯è¯´, æˆ‘ä»¬éœ€è¦èŠ±è´¹ä¸€å®šçš„ç®—åŠ›, å»å°† gyro çš„æµ‹é‡ä¿¡å·ä» body ç³»è½¬æ¢åˆ°æ‰€éœ€çš„ç³»ä¸­.\nThe Navigation Equations # The Navigation Equations form the core of all strapdown inertial navigation systems.\nå¯¹äºå¯¼èˆªæ–¹ç¨‹æˆ‘ä»¬æœ‰å¦‚ä¸‹æ›´ general çš„è¡¨è¾¾å½¢å¼:\naâ€¾ibÎ³=fâ€¾ibÎ³+Î³â€¾ibÎ³\\underline{a}^{\\gamma}_{ib} = \\underline{f}^{\\gamma}_{ib} + \\underline{\\gamma}^{\\gamma}_{ib} æ¥ä¸‹æ¥, æˆ‘ä»¬è¦æ±‚è§£ä¸¤ä¸ªä¸åŒçš„å¯¼èˆªæ–¹ç¨‹.\nEarth-Frame Navigation Equations # ECEF ç³»é€šå¸¸è¢«å«æ˜Ÿç³»ç»Ÿ (i.e. GNSS) ç”¨äºå‚è€ƒç³»å’Œè§£æç³». å› æ­¤, æˆ‘ä»¬ä¹Ÿå¸Œæœ›æˆ‘ä»¬è½¦å­çš„å¯¼èˆªå¯ä»¥åœ¨ç›¸åŒçš„ç³»ä¸‹è¿›è¡Œè§£æ.\næˆ‘ä»¬å¯ä»¥é‡å†™ Navigation Equation åœ¨ Fe\\mathscr{F}^e :\naâ€¾ibe=fâ€¾ibe+eâ€¾ibÎ³\\underline{a}^{e}_{ib} = \\underline{f}^{e}_{ib} + \\underline{e}^{\\gamma}_{ib} åœ¨å®é™…ä½¿ç”¨è¿™ä¸ªæ–¹ç¨‹æ—¶, æˆ‘ä»¬ä¼šå‘ç°, ç”±äºä¼ æ„Ÿå™¨æ˜¯å›ºå®šåœ¨ body ä¸Šçš„, æ‰€ä»¥æˆ‘ä»¬æµ‹é‡çš„æ¯”åŠ›æ˜¯ fâ€¾ibb\\underline{f}^{b}_{ib} .\nå› æ­¤:\naâ€¾ibe=Cbefâ€¾ibb+eâ€¾ibÎ³\\underline{a}^{e}_{ib} = C^{e}_{b}\\underline{f}^{b}_{ib} + \\underline{e}^{\\gamma}_{ib} é‚£ä¹ˆ, æˆ‘ä»¬è¦å¦‚ä½•ä»è¿™ä¸ªå¼å­é‡Œæ±‚è§£å‡ºæˆ‘ä»¬æ„Ÿå…´è¶£çš„ vâ€¾ebe\\underline{v}^{e}_{eb} ? (å…¶å‚è€ƒç³»æ˜¯ ECEF)\nç„¶è€Œ, è¿™è¿˜æ²¡æœ‰ç»“æŸ. åœ¨å®é™…ä½¿ç”¨è¿‡ç¨‹ä¸­, æˆ‘ä»¬éœ€è¦å®æ—¶æ›´æ–° CbeC^e_b , é€šè¿‡ä¸‹é¢å…¬å¼:\nCbeË™=CbeÎ©ebb\\dot{C^e_b} = C^e_b\\Omega^b_{eb} ç„¶è€Œ, æˆ‘ä»¬æ— æ³•å¾—åˆ° Î©ebb\\Omega^b_{eb} , å› ä¸ºæˆ‘ä»¬çš„ gyro åªèƒ½æµ‹é‡æƒ¯æ€§ç³»çš„é‡, ä¹Ÿå°±æ˜¯ Ï‰â€¾ibb\\underline{\\omega}^b_{ib} .\nå› æ­¤, æˆ‘ä»¬éœ€è¦é€šè¿‡ä¸€ä¸‹æ–¹æ³•å¾—åˆ°:\nç„¶è€Œ, é—®é¢˜ä¾æ—§æ²¡æœ‰ç»“æŸ!!!!\nå› ä¸ºå®ƒè¿˜æ˜¯ç”¨åˆ°äº†åœ¨ body ç³»è§£æçš„åœ°çƒçš„è½¬åŠ¨é€Ÿåº¦ Î©ibe\\Omega^b_ie , ç„¶è€Œæˆ‘ä»¬å®é™…çŸ¥é“çš„æ˜¯ ECEF ç³»è§£æçš„è½¬åŠ¨é€Ÿåº¦ Î©iee\\Omega^e_ie .æ‰€ä»¥, æˆ‘ä»¬è¿˜å¾—è¿™æ ·:\nç»ˆäº, æˆ‘ä»¬å¯ä»¥å¼€å¿ƒåœ°æ›´æ–°è¿™ä¸ªåæ ‡å˜æ¢çŸ©é˜µäº†!!!!\nå…¶æ€»çš„æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤º:\nLocal Navigation Frame Equations # åœ¨è¿™ä¸ªè§£æç³»ä¸‹, æ±‚è§£ vâ€¾ebn\\underline{v}^{n}_{eb} è¿‡ç¨‹å¦‚ä¸‹:\nåœ¨æ›´æ–°å§¿æ€æ—¶, ä¹Ÿæœ‰ä¸€äº›ä¸åŒ:\nå¯ä»¥å‘ç°, ä¸Šè¿°å¼å­ä¸­æœ‰ä¸‰ä¸ª Î©\\Omega , å…¶ä¸­, ç¬¬ä¸€ä¸ªæ˜¯ gyro æµ‹é‡çš„.\nç¬¬äºŒä¸ªä¸åœ°çƒçš„è‡ªè½¬æœ‰å…³:\nç¬¬ä¸‰ä¸ªè¢«ç§°ä½œ Transport Rate, ä¹Ÿå°±æ˜¯å’Œ NED ç³»ç›¸å¯¹äº ECEF ç³»çš„æ—‹è½¬æœ‰å…³.\næ€»çš„æµç¨‹å¦‚ä¸‹:\nINS Update Steps # Update attitude Transform specific force frame Update velocity Update position Inertial Sensors # Accelerometers # åŠ é€Ÿåº¦ä»ªä¸»è¦æœ‰ä»¥ä¸‹ä¸¤ç§ç±»åˆ«:\nconventional mechanical MEMS (Micro-Electro Mechanical Machines). piezoelectric devices (æ›´ç²¾ç¡®, ä½†ä¹Ÿå¸¦æ¥äº†æ›´å¤šçš„ size/weight/volume/unit cost) capacitive devices (most common) conventional mechanical # MEMS Capacitive Accelerometer # Gyroscopes # gyro å¯ä»¥åˆ†æˆå¦‚ä¸‹å‡ ç±»:\nMechanical rate gyroscopes: use the conservation of angular momentum to measure angular rate MEMS gyroscopes: use the Coriolis effect to measure angular rate Optical gyroscopes: use the Sagnac effect to achieve the same measurement. Mechanical Gyroscopes # Vibrating Structure Gyroscopes (VSG) # Laser Gyroscopes # Sensor Error Characteristics # Bias Error # acc å’Œ gyro éƒ½æœ‰.\nBias ä¼šå˜, è¿™ä¸€æ€§è´¨è¢«ç§°ä¸º bias instability. ä¸€èˆ¬ MEMS çš„ BS è¦æ¯”æœºæ¢°çš„é«˜.\nScale Factor Errors # ä¸€èˆ¬ä¼ æ„Ÿå™¨çš„è¾“å…¥è¾“å‡ºä¼šæœ‰ä¸€ä¸ªæ¯”å€¼, æˆ‘ä»¬ç§°ä¹‹ä¸º scale factor (SF).\nCross-Coupling Errors # å…¶ç»å¸¸ä¸ SF error ä¸€èµ·ç”¨å¦‚ä¸‹çŸ©é˜µæè¿°:\nRandom Noise # Thermo-Mechanical White Noise\nError Models # æœ€å, å‡ ä¸ªè¯¯å·®å…¨éƒ¨åŒ…å«è¿›æ¥å, æ€»çš„è¾“å‡ºæ˜¯:\nå¯¹åº”çš„è¯¯å·®ä¹Ÿå¯ä»¥å¾—åˆ°:\nè¿™äº›è¯¯å·®ä¹Ÿå¯ä»¥è¢«ä¿®æ­£:\n"},{"id":6,"href":"/docs/example/my-blog/navigation/navi_l4/","title":"L4.å«æ˜Ÿå¯¼èˆª","section":"å¯¼èˆª","content":" Satellite Navigation # Radio Navigation and Trilateration # é›·è¾¾å¯¼èˆªçš„åŸºç¡€æ˜¯ç”µç£æ³¢åœ¨çœŸç©ºä¸­ä»¥å…‰é€Ÿä¼ æ’­. æ‰€ä»¥åªéœ€è¦çŸ¥é“å…‰ä¼ æ’­çš„æ—¶é—´, å°±å¯ä»¥æµ‹ç®—å‡ºå¯¹åº”çš„è·ç¦».\nä¸‰ä¸ªé›·è¾¾å¯ä»¥ç¡®å®šä¸€ä¸ªå…·ä½“çš„ä½ç½®, è¿™å°±å«ä¸‰ç‚¹å®šä½æ³• (Trilateration)\nå®ƒçš„è®¡ç®—æ­¥éª¤ååˆ†ç¹ç! ä½†æ˜¯é€‚åˆç”µè„‘. æµç¨‹å¦‚ä¸‹:\nå…¶ä¸­, dr æ˜¯ true r - predicted r.\nè¿˜æœ‰, é‡Œé¢æåˆ°çš„ H, æ˜¯é›…å„å¸ƒçŸ©é˜µ (Jacobian Matrix):\nå¦‚æœæ˜¯ 3 ä¸ª beacon çš„è¯, é‚£ä¹ˆ Hâˆ’1H^{-1} éœ€è¦é€šè¿‡Moore-Penrose pseudo inverse çš„æ–¹æ³•æ¥å®ç°:\nGNSS Architecture # å…¨çƒå«æ˜Ÿå¯¼èˆªç³»ç»Ÿ (Global Navigation Satellite System, GNSS), ä¸€èˆ¬åŒ…å«ä¸‰ä¸ªéƒ¨åˆ†:\nSpace segment Ground control segment User segment Space segment # å…¶ä¸­, æˆ‘ä»¬æ„Ÿå…´è¶£çš„éƒ¨åˆ†æœ‰:\nDirected antenna array pointed at the earth Atomic clock. The space segment consists of a constellation of 24 satellites. Each satellite broadcasts its position and a very accurate measurement of the broadcast time provided by an on-board caesium or rubidium atomic clock. There are two broadcast signals, each modulated by a binary phase shift keying digital process encoding a pseudo-random signal and a data signal.\nGround control segment # The control segment monitors the position and status of each satellite and issues course correction commands, clock adjustment commands, satellite almanac information and ionospheric correction factors.\nUser segment # The user segment consists of an antenna to receive the broadcast signal from each satellite in view, a receiver segment to demodulate each satellite signal and recover both the pseudorange measurement and data message and a processing segment to correct the pseudorange measurements and compute a position, velocity, time navigation solution using trilateration.\nSources of Error # 8 principle sources of error in a GNSS system\nSatellite clock errors: Receiver clock error: Ionospheric refraction: ç¦»å­å±‚æŠ˜å°„ Tropospheric refraction: å¯¹æµå±‚æŠ˜å°„ Satellite geometry: Dilution of precision. Relativity effects:Due to special and general relativity, the clocks on-board the satellites run faster than identical clocks on earth. Multipath errors: landscape surrounding the receiver. Receiver tracking errors: Thermal noise and interference eï¬€ects Geometric - Dilution of Precision # Single-Point Navigation Solution # "},{"id":7,"href":"/docs/example/my-blog/navigation/navi_l5/","title":"L5.é›†æˆå¯¼èˆª","section":"å¯¼èˆª","content":" Integrated Navigation # Principles of Sensor Fusion # å¼•å…¥äº†ä¸€ä¸ªå°çš„çŸ¥è¯†ç‚¹:\nto fuse the information from two pdfs we can multiply them together\nThe Kalman Filter # å¡å°”æ›¼æ»¤æ³¢ (Kalman Filter) çš„å·¥ä½œæ­¥éª¤:\nA Prediction Step and A Measurement Update Step Filter Equations # We use â€™âˆ’â€™ to differentiate between Â´a priori and Â´a posteriori estimates, i.e. estimates from the prediction step (Â´a priori) and those modified by the measurement step (Â´a posteriori)\na priori estimateï¼ˆå…ˆéªŒä¼°è®¡ / é¢„æµ‹ä¼°è®¡ï¼‰ a posteriori estimateï¼ˆåéªŒä¼°è®¡ / æ›´æ–°åçš„ä¼°è®¡ï¼‰ è¿™å¼ å›¾å±•ç¤ºçš„æ˜¯ æ ‡å‡†ç¦»æ•£å¡å°”æ›¼æ»¤æ³¢å™¨çš„é¢„æµ‹ï¼ˆTime Updateï¼‰å’Œæ›´æ–°ï¼ˆMeasurement Updateï¼‰æ–¹ç¨‹ã€‚\nâ¸»\nğŸŸ¥ Time Updateï¼ˆé¢„æµ‹ / å…ˆéªŒï¼‰\nx^kâˆ’\\hat{x}_k^{-} å…ˆéªŒçŠ¶æ€ä¼°è®¡ï¼ˆpredictionï¼‰ å³ï¼šæ ¹æ®ç³»ç»Ÿæ¨¡å‹é¢„æµ‹å¾—åˆ°çš„çŠ¶æ€ï¼Œä½†è¿˜æ²¡æœ‰ç”¨æµ‹é‡ä¿®æ­£ã€‚\nx^kâˆ’=Î¦kâˆ’1x^kâˆ’1\\hat{x}_k^{-} = \\Phi_{k-1} \\hat{x}_{k-1} â¸»\nÎ¦kâˆ’1\\Phi_{k-1} çŠ¶æ€è½¬ç§»çŸ©é˜µï¼ˆState Transition Matrixï¼‰\nå®ƒæè¿°ç³»ç»ŸçŠ¶æ€åœ¨ç¦»æ•£æ—¶é—´æ­¥ä¹‹é—´æ˜¯å¦‚ä½•æ¼”åŒ–çš„ã€‚\nä¾‹å¦‚ä½ç½®é€Ÿåº¦ç³»ç»Ÿï¼š\nxk=xkâˆ’1+vkâˆ’1dtx_k = x_{k-1} + v_{k-1} dt â€”\nPkâˆ’P_k^{-} å…ˆéªŒåæ–¹å·®çŸ©é˜µï¼ˆprediction covarianceï¼‰ ä»£è¡¨çŠ¶æ€é¢„æµ‹çš„ä¸ç¡®å®šæ€§ã€‚\nPkâˆ’=Î¦kâˆ’1Pkâˆ’1Î¦kâˆ’1T+QkP_k^{-} = \\Phi_{k-1} P_{k-1} \\Phi_{k-1}^T + Q_k â¸»\nQkQ_k è¿‡ç¨‹å™ªå£°åæ–¹å·®ï¼ˆProcess noise covarianceï¼‰\nä»£è¡¨ç³»ç»Ÿæ¨¡å‹çš„ä¸ç¡®å®šæ€§ï¼Œä¾‹å¦‚ï¼š\nåŠ é€Ÿåº¦æ¨¡å‹ä¸å‡† å¤–ç•Œå¹²æ‰° IMU å™ªå£° QkQ_k ä¼š ä½¿é¢„æµ‹çš„ä¸ç¡®å®šæ€§å˜å¤§ã€‚\nâ¸»\nğŸŸ© Measurement Updateï¼ˆä¿®æ­£ / åéªŒï¼‰\nKkK_k å¡å°”æ›¼å¢ç›Šï¼ˆKalman Gainï¼‰\nKk=Pkâˆ’HkT(HkPkâˆ’HkT+Rk)âˆ’1K_k = P_k^{-} H_k^T (H_k P_k^{-} H_k^T + R_k)^{-1} ç›´è§‚æ„ä¹‰ï¼š\nå†³å®šä¿¡ä»»æµ‹é‡å¤šå°‘ vs ä¿¡ä»»é¢„æµ‹å¤šå°‘\nè‹¥ RkR_k ï¼ˆæµ‹é‡å™ªå£°ï¼‰å¤§ â†’ ä¿¡é¢„æµ‹ è‹¥ Pkâˆ’P_kâ» ï¼ˆæ¨¡å‹ä¸ç¡®å®šï¼‰å¤§ â†’ ä¿¡æµ‹é‡ â¸»\nzkz_k æµ‹é‡å‘é‡ï¼ˆMeasurementï¼‰\næ¥è‡ªä¼ æ„Ÿå™¨çš„å®é™…æµ‹é‡å€¼ å¦‚ GPS ä½ç½®ã€é€Ÿåº¦è®¡è¯»æ•°ã€IMU æµ‹é‡ç­‰ã€‚\nâ¸»\nHkH_k æµ‹é‡çŸ©é˜µï¼ˆMeasurement Matrixï¼‰\næè¿°çŠ¶æ€å¦‚ä½•æ˜ å°„åˆ°æµ‹é‡ï¼š\nzk=Hkxk+vkz_k = H_k x_k + v_k ä¾‹å­ï¼š è‹¥æµ‹é‡åªè§‚æµ‹åˆ°ä½ç½®ï¼š\nHk=[1â€…0]H_k = [1 \\; 0] â¸»\nx^k\\hat{x}_k åéªŒçŠ¶æ€ä¼°è®¡ï¼ˆä¿®æ­£åçš„çŠ¶æ€ï¼‰\nx^k=x^kâˆ’+Kk(zkâˆ’Hkx^kâˆ’)\\hat{x}_k = \\hat{x}_k^{-} + K_k(z_k - H_k\\hat{x}_k^{-}) æ‹¬å·é‡Œçš„é¡¹å« innovationï¼ˆåˆ›æ–° / æ®‹å·®ï¼‰\nzkâˆ’Hkx^kâˆ’z_k - H_k \\hat{x}_k^{-} è¡¨ç¤ºæµ‹é‡ä¸é¢„æµ‹ä¹‹é—´çš„å·®å€¼ã€‚\nâ¸»\nPkP_k åéªŒåæ–¹å·®ï¼ˆä¿®æ­£åçš„ä¸ç¡®å®šæ€§ï¼‰\nPk=(Iâˆ’KkHk)Pkâˆ’P_k = (I - K_k H_k) P_k^{-} åéªŒä¸ç¡®å®šæ€§ä¼šæ¯”å…ˆéªŒå° è¡¨ç¤ºçŠ¶æ€ä¼°è®¡å˜å¾—æ›´ç²¾ç¡® â¸»\nRkR_k æµ‹é‡å™ªå£°åæ–¹å·®ï¼ˆMeasurement noise covarianceï¼‰\nä»£è¡¨ä¼ æ„Ÿå™¨å™ªå£°çš„å¤§å°ã€‚\nä¾‹å¦‚ï¼š\nGPS å™ªå£°å¯èƒ½æ˜¯ 3 mï¼Œ RkR_k è¾ƒå¤§ æ¿€å…‰é›·è¾¾å™ªå£°å¯èƒ½æ˜¯ 0.1 mï¼Œ RkR_k è¾ƒå° â¸»\nAnalysis of Filter # 2D Navigation Example # Integrated INS/GNSS Navigation # Integration Architecture # INS/GNSS Kalman Filter # Integrated Navigation Example # "},{"id":8,"href":"/docs/example/my-blog/digital_control/dc_ch6/","title":"CH6.ç¨³å®šæ€§","section":"æ•°å­—æ§åˆ¶","content":" 6 Stability # 6.1 Asymptotic stability # A system is asymptotically stable if its steady-state (i.e. at infinite time) response to any initial condition decays to zero.\ny(âˆ)=0,âˆ€y(0)y(\\infty)=0, \\forall y(0) "}]