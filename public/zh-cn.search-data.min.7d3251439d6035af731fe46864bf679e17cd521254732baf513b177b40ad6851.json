[{"id":0,"href":"/docs/example/my-blog/pns/pns_ch1/","title":"CH1.è§„åˆ’è°ƒåº¦: è§’è‰²ä¸å½±å“","section":"å·¥ä¸šç”Ÿäº§è§„åˆ’è°ƒåº¦é˜…è¯»ç¬”è®°","content":" 1.1 Planning and Scheduling: Role and Impact # è§„åˆ’ ä¸ è°ƒåº¦ æ˜¯ å†³ç­–åˆ¶å®š (decision-making) ä¸€ç§å½¢å¼.\nå†³ç­–åˆ¶å®š åœ¨åˆ¶é€ æœåŠ¡äº§ä¸šä¸­ å¯ä»¥ç”¨æ¥\né‡‡è´­ä¸ç”Ÿäº§ (procurement and production) è¿è¾“ä¸åˆ†å‘ (transportation and distribution) ä¿¡æ¯å¤„ç†ä¸é€šè®¯ (information processing and communication) ç­‰ç­‰.\næˆ‘ä»¬å¸Œæœ›æˆ‘ä»¬çš„è§„åˆ’ä¸è°ƒåº¦ç®—æ³•å¯ä»¥åšåˆ°:\nallocate limited resources to the activities to be done so that the company can optimize its objectives and achieve its goals.\nè¿™é‡Œçš„ èµ„æº (resources) ä¸€èˆ¬å¯ä»¥æ˜¯:\nè½¦é—´é‡Œçš„æœºå™¨ (machines in a workshop) é£æœºåœºçš„è·‘é“ (runways at an airport) å·¥åœ°çš„å‘˜å·¥ (crews at a construction site) è®¡ç®—æœºçš„å¤„ç†å•å…ƒ (processing units in a computing environment) è¡ŒåŠ¨ (activities) ä¸€èˆ¬å¯ä»¥æ˜¯:\nè½¦é—´é‡Œæœºå™¨çš„è¿è¡Œå¤„ç†è¡ŒåŠ¨ (operations in a workshop) æœºåœºé‡Œé£æœºçš„èµ·é£é™è½è¡ŒåŠ¨ (take-oï¬€s and landings at an airport) å·¥åœ°é¡¹ç›®çš„ä¸€ä¸ªé˜¶æ®µ? (stages in a construction project) è®¡ç®—æœºç¨‹åºçš„æ‰§è¡Œ (computer programs that have to be executed) ç›®æ ‡ (objectives) æœ‰å¾ˆå¤šç§å½¢å¼, ä¸€èˆ¬å¯ä»¥æ˜¯:\nå‡å°‘å®Œæˆæ‰€æœ‰ ä»»åŠ¡ çš„æ€»æ—¶é—´ å‡å°‘è¶…æ—¶å®Œæˆçš„ ä»»åŠ¡ çš„æ•°é‡ ç„¶åä¹¦ä¸Šä¾‹ä¸¾äº†10ä¸ªä¾‹å­æ¥è¯´æ˜è¿™äº›æ¦‚å¿µ (ç•¥).\n1.2 Planning and Scheduling Functions in an Enterprise # Planning and Scheduling in Manufacturing. # åœ¨åˆ¶é€ ä¸šä¸­, æ¯ä¸€ä»½ è®¢å• (order) éƒ½éœ€è¦è¢«æ‹†è§£æˆ æ‹¥æœ‰ æˆªæ­¢æ—¥æœŸ (due date) çš„ ä»»åŠ¡ (jobs).\nè¿™äº› ä»»åŠ¡ éœ€è¦ æœºå™¨ æŒ‰ç…§ä¸€å®šçš„é¡ºåºæ¥è¿›è¡Œå¤„ç†.\nç„¶è€Œ, å¤„ç†å¯èƒ½ä¼šè¢«å»¶è¿Ÿ, å¦‚æœé‡åˆ°æŸå°æœºå™¨å¾ˆå¿™çš„æƒ…å†µ. å› æ­¤, ä¸ºäº†å¤„ç† é«˜ä¼˜å…ˆçº§ä»»åŠ¡, æˆ‘ä»¬éœ€è¦ç”¨ æŠ¢å å¼è°ƒåº¦ (preemptions).\næœ‰æ—¶, æŸäº›çªå‘äº‹ä»¶ä¹Ÿéœ€è¦è¢«è€ƒè™‘è¿›æ¥, æ¯”å¦‚:\næœºå™¨åæ‰ è¶…å‡ºé¢„æœŸçš„å¤„ç†æ—¶é—´ åœ¨è¿™æ ·çš„åœºæ™¯ä¸‹, æˆ‘ä»¬çš„ ç›®æ ‡ å°±æ˜¯é«˜æ•ˆç‡å’Œå¯æ§ç”Ÿäº§.\næ¥ä¸‹æ¥, ä½œè€…å†æ¬¡å¼ºè°ƒäº† scheduling å’Œ planning çš„åŒºåˆ«:\nThe shopfloor is not the only part of the organization that impacts the scheduling process. The scheduling process also interacts with the production planning process, which handles medium- to long-term planning for the entire organization.\nç®€è¨€ä¹‹, scheduling ä¸ä»…ä¼šæ”¶åˆ°è½¦é—´æœ¬èº«çŠ¶å†µçš„å½±å“, åŒæ—¶ä¹Ÿä¼šæ”¶åˆ° planningçš„å½±å“, ä¹Ÿå°±æ˜¯ä½ é‡‡ç”¨çš„è§„åˆ’ç®—æ³•.\nåœ¨è¿™ä¸ªåœºæ™¯ä¸‹, è§„åˆ’ç®—æ³• çš„åˆ¶å®šä¸€èˆ¬ä¼šåŸºäºä»¥ä¸‹è€ƒé‡:\nä»“å‚¨æƒ…å†µ (inventory levels) éœ€æ±‚é¢„æµ‹ (demand forecasts) èµ„æºéœ€æ±‚ (resource requirements) åœ¨äº†è§£ä¸Šé¢è¿™äº›æ¦‚å¿µå, æˆ‘ä»¬å¯ä»¥å¼€å§‹çœ‹ä¸€ä¸ªæ›´è¯¦ç»†çš„ç”Ÿäº§ç³»ç»Ÿçš„ä¿¡æ¯æµå›¾:\né‡Œé¢æœ‰å¾ˆå¤šæ–°çš„æ¦‚å¿µ, æˆ‘ä»¬å¯ä»¥ä¸€ä¸ªä¸ªçœ‹. é¦–å…ˆ, æˆ‘ä»¬çš„å†…éƒ¨ç³»ç»Ÿè‚¯å®šæ˜¯è¦ä¸å¤–éƒ¨ç³»ç»Ÿè¿›è¡Œæ²Ÿé€šå’Œ(å¯¹é½)çš„:\nIn manufacturing, planning and scheduling has to interact with other decision making functions in the plant.\nå…¶ä¸­ä¸€ä¸ªæ¯”è¾ƒå¸¸è§çš„ç³»ç»Ÿæ˜¯ Material Requirements Planning (MRP) system. ç”±äºæ¯ä¸ª è°ƒåº¦ éƒ½éœ€è¦å·¥å‚èƒ½å¤Ÿåœ¨åˆ¶å®šæ—¶é—´æ—¶æ‹¥æœ‰è¶³å¤Ÿçš„ èµ„æº (resources) å’Œ åŸææ–™ (raw materials), æ‰€ä»¥ MRP ç³»ç»Ÿä¼šæ ¹æ®å½“å‰çš„ä»“å‚¨é‡æ¥å†³å®šä¹°å…¥åŸææ–™çš„æ—¶é—´. MRP ç›®å‰å·²ç»æœ‰æˆç†Ÿçš„å•†ä¸šè½¯ä»¶å¯ä»¥ä½¿ç”¨.\nå¦ä¸€ä¸ªå¸¸è§çš„ç³»ç»Ÿæ˜¯ Enterprise Resource Planning (ERP) systems. å°±æ˜¯ç”¨äºæŠŠå„ä¸ªç§äººç”µè„‘å’Œæ•°æ®ä¸­å¿ƒçš„æ•°æ®æ‹‰é½. æœ‰æ—¶ä¹Ÿä¼šä¸ä¾›åº”å•†/å®¢æˆ·çš„æ•°æ®ç›¸è¿. å†³ç­–è¾…åŠ©ç³»ç»Ÿä¸€èˆ¬éœ€è¦ä¸ ERP ç›¸è¿.\nPlanning and Scheduling in Services. # ç•¥\n1.3 Outline of the Book # "},{"id":1,"href":"/docs/example/my-blog/qam/","title":"åŠ¨æ€QAMè°ƒåˆ¶è§£è°ƒpythonå®ç°","section":"åšå®¢","content":" å¼•å…¥ # é¢˜ç›®åŸºäº University of Glasgow å¤§ä¸‰è¯¾ç¨‹ ENG3014 Communications Systems 3 çš„è¯¾ç¨‹å¤§ä½œä¸š, å¸Œæœ›æˆ‘ä»¬ç”¨è¯¾ç¨‹å­¦åˆ°çš„çŸ¥è¯†å†™ä¸€ä¸ªç®€å•çš„ä¿¡æ¯æ”¶å‘æ¨¡æ‹Ÿç¨‹åº:\nThis should include at minimum:\nA message of your choice, comprising more than 2048 bits, converted from a â€œSTRINGâ€ to a â€œBINARYâ€. Using your modulation format of choice, modulate a carrier to encode this information. The channel SNR to be considered will be 6dB, 18dB and 24dB with respect to AGWN. An output filter limiting the transmitter bandwidth to less than 20% of the carrier frequency. Demodulation of the signal and recovery of the signal. Please analyse the Bit Error Rate of the received signal over multiple retransmission of the signal over the simulated channel. Discuss in your report choices you make, such as modulation format, Baud Rate, Filter type and bandwidth. Up to 30% of the marks allocated will be included for creative additions (10% each), these could include:\nSimulate fading conditions associated with an urban environment. Implementation of Hamming coding or other error correction technique. Transmission of video, audio or other time varying signal over the channel. Dynamic modulation, based on measured system performance. Automatic resending of errored signals. Or anything else you think would be a cool addition! :-(\nå½’çº³ä¸€ä¸‹å·®ä¸å¤šå¦‚ä¸‹:\nå°† String çš„è¾“å…¥è½¬åŒ–ä¸ºç”± 0 å’Œ 1 ç»„æˆçš„äºŒè¿›åˆ¶ç¼–ç . ç”¨ Hamming code ç¼–ç . åŠ å…¥å™ªéŸ³. é€‰ä¸€ä¸ªå–œæ¬¢çš„åŠæ³•è°ƒåˆ¶. å†è§£è°ƒ. è®¡ç®—è¯¯ç ç‡ç­‰å…¶ä»–ç©æ„å„¿. æˆ‘çš„é¡¹ç›®åšäº†ä¸‹é¢çš„æ­¥éª¤:\nå›¾1: å®ç°æµç¨‹å›¾ ä¸è¦æ…Œ, æˆ‘ä»¬ä¸€æ­¥æ­¥çœ‹ğŸ‘€.\nåº“ # import numpy as np from numpy import log2, arange, sqrt, flip, concatenate, zeros, array, floor, sqrt, array, bitwise_xor from numpy.random import randint import math from math import ceil from matplotlib import pyplot as plt from scipy import signal from hamming import encode, decode from bitarray import bitarray String ä¸ Binary çš„è½¬æ¢ # def string2bits(s=\u0026#39;\u0026#39;): out = \u0026#39;\u0026#39;.join([bin(ord(x))[2:].zfill(8) for x in s]) return [int(x) for x in list(out)] å¥½å¤šå¥‡å¥‡æ€ªæ€ªçš„å‡½æ•°, æ…¢æ…¢æŸ¥å§ğŸ˜©.\nord(x): è¿”å›ä»£è¡¨å­—ç¬¦ x çš„ unicode ç¼–ç  (int), æ¯”æ–¹è¯´: â€˜aâ€™ çš„ unicode ç¼–ç æ˜¯ 97, â€˜?â€™ çš„æ˜¯ 63.\nbin(ord(x)): è¿”å›xçš„unicodeç¼–ç çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸² (string), æ³¨æ„:ord()çš„è¾“å‡ºæ˜¯åè¿›åˆ¶çš„å‘€. æ¯”å¦‚:\n'a' -\u0026gt; 97 -\u0026gt; \u0026quot;0b1100001\u0026quot;\n'?' -\u0026gt; 63 -\u0026gt; \u0026quot;0b111111\u0026quot;\næ³¨æ„åˆ°è¿™é‡Œçš„å­—ç¬¦ä¸²å‰é¢å¸¦äº† 0b, å› æ­¤æˆ‘ä»¬éœ€è¦:\nbin(ord(x))[2:]: å»æ‰ 0b\n'a' -\u0026gt; 97 -\u0026gt; \u0026quot;0b1100001\u0026quot; -\u0026gt; \u0026quot;1100001\u0026quot;\n'?' -\u0026gt; 63 -\u0026gt; \u0026quot;0b111111\u0026quot; -\u0026gt; \u0026quot;111111\u0026quot;\nåˆæ³¨æ„åˆ°æ¯ä¸ªå­—ç¬¦ä¸²é•¿åº¦ä¸ä¸€æ ·, è¿™å¯èƒ½ä¼šè®©æˆ‘ä»¬åœ¨è§£ç çš„æ—¶å€™å‡ºç°é—®é¢˜, å› æ­¤æˆ‘ä»¬éœ€è¦:\nbin(ord(x))[2:].zfill(8): è¡¥é½å­—ç¬¦ä¸²åˆ°8ä½\n'a' -\u0026gt; 97 -\u0026gt; \u0026quot;0b1100001\u0026quot; -\u0026gt; \u0026quot;1100001\u0026quot; -\u0026gt; \u0026quot;01100001\u0026quot;\n'?' -\u0026gt; 63 -\u0026gt; \u0026quot;0b111111\u0026quot;-\u0026gt; \u0026quot;111111\u0026quot; -\u0026gt; \u0026quot;00111111\u0026quot;\nout = ''.join([bin(ord(x))[2:].zfill(8) for x in s]): å°†æ‰€æœ‰å­—ç¬¦è½¬æ¢åçš„ 8 ä½äºŒè¿›åˆ¶æ‹¼æ¥æˆä¸€ä¸ªé•¿å­—ç¬¦ä¸².\n'a?' -\u0026gt; \u0026quot;0110000100111111\u0026quot;\nä½†æ˜¯å› ä¸ºæ•´å½¢(int)è¦æ›´å¥½å¤„ç†ä¸€äº›, æˆ‘ä»¬æœ€åå†æ¢ä¸€æ¢:\nreturn [int(x) for x in list(out)]: éå†æ¯ä¸€ä¸ªå­—ç¬¦ (char), å°†å…¶æ¢æˆæ•´å½¢ (int):\n'a?' -\u0026gt; \u0026quot;0110000100111111\u0026quot; -\u0026gt; [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1]\nå½“å½“~~\næ—¢ç„¶éƒ½æŠŠè¿™ä¹ˆä¹±ä¸ƒå…«ç³Ÿçš„è½¬æ¢ææ‡‚äº†, é‚£å°±ä¸å¦¨å†çœ‹çœ‹æ€ä¹ˆæŠŠå®ƒå˜å›å». (Binary -\u0026gt; String)\ndef bits2string(b=None): return \u0026#39;\u0026#39;.join([chr(int(x, 2)) for x in b]) é“ç†ä¹Ÿå¤§å·®ä¸å·®, [... for x in b] ç”¨æ¥éå†Binaryæ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ , int(x, 2) å°†äºŒè¿›åˆ¶çš„è¾“å…¥å˜æˆ 10 è¿›åˆ¶, chr() å†æŠŠå®ƒå˜æˆå­—ç¬¦, æœ€åå†ç”¨ ''.join() åˆå¹¶åœ¨ä¸€èµ·.\nAWGN å™ªéŸ³ # å’±å…ˆè·³è¿‡ Hamming Code, çœ‹çœ‹æ€ä¹ˆåŠ  AWGN å™ªéŸ³:\ndef awgn(signal, snr, seed=False): \u0026#39;\u0026#39;\u0026#39; Additive White Gaussian Noise (AWGN) function. \u0026#39;\u0026#39;\u0026#39; if seed: np.random.seed(1) # Calculate the signal power as the average of the squared magnitudes of the signal sigpower = sum([math.pow(abs(signal[A_I]), 2) for A_I in range(len(signal))]) sigpower = sigpower / len(signal) # Calculate the noise power based on the SNR # SNR (in linear scale) = Signal Power / Noise Power noisepower = sigpower / (math.pow(10, snr/10)) # Generate Gaussian noise with mean 0 and standard deviation based on noise power noise = np.random.normal(0, np.sqrt(noisepower), len(signal)) return np.array([noise]) å…¶ä¸­\nsigpower = sum([math.pow(abs(signal[A_I]), 2) for A_I in range(len(signal))]) sigpower = sigpower / len(signal) éå† signal (å³ä¹‹å‰æåˆ°çš„ [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1])ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ , å°†å…¶å¹³æ–¹ç›¸åŠ , ç„¶åå†é™¤ä»¥æ€»é•¿, è®¡ç®—ä¿¡å·åŠŸç‡.\né‚£ä¹ˆä¸ºä»€ä¹ˆè¦è®¡ç®—ä¿¡å·åŠŸç‡å‘¢? ç”±ä¿¡å™ªæ¯”å…¬å¼:\n\\[ \\mathrm{SNR}_{\\text{dB}} = 10 \\log_{10} \\left( \\frac{P_{\\text{signal}}}{P_{\\text{noise}}} \\right) \\] å…¶ä¸­:\n\\( \\mathrm{SNR}_{\\text{dB}} \\) : ä¿¡å™ªæ¯”ï¼ˆåˆ†è´è¡¨ç¤ºï¼‰ \\( P_{\\text{signal}} \\) : ä¿¡å·åŠŸç‡ \\( P_{\\text{noise}}ï¼š \\) : å™ªå£°åŠŸç‡ å› æ­¤, é€šè¿‡ç»™å®šçš„ä¿¡å™ªæ¯” SNR, æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¿¡å·åŠŸç‡åæ¨å‡ºåº”è¯¥åŠ å…¥çš„å™ªå£°åŠŸç‡. ä¹Ÿå°±æ˜¯è¿™ä¸€æ­¥:\nnoisepower = sigpower / (math.pow(10, snr/10)) ç„¶åå†é€šè¿‡è¿™ä¸€å™ªå£°åŠŸç‡è®¡ç®—å‡º AWGN (ä¹Ÿå°±æ˜¯è¿™ä¸ªå‡½æ•°çš„è¾“å‡º), æœ€åå’ŒåŸæœ¬çš„ä¿¡å·åšä¸ªåŠ æ³•å°±è¡Œå•¦~\n[0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1]\nSNR=24:\narray([[-0.03305892, 0.93648725, 1.07229167, 0.03032389, -0.08373429, -0.04651428, -0.02556458, 1.04447924, -0.04254978, -0.01583561, 1.01729117, 0.98901276, 1.01125261, 0.97203918, 1.07735198, 1.03366213]]) SNR=6:\narray([[ 0.15621611, 0.5966272 , 0.40825385, -0.03236429, 0.80902723, 0.67793688, 0.05471882, 1.1841027 , -0.48631011, -0.56585869, 1.15182751, 0.44881134, 0.74662291, 0.95341178, 0.9046891 , 0.71363364]]) å¯ä»¥æ˜æ˜¾å‘ç°ä¿¡å™ªæ¯” SNR è¶Šå¤§(å¦‚ SNR=24), å™ªéŸ³å¯¹ä¿¡å·çš„å½±å“è¶Šå°, åä¹‹, ä¿¡å™ªæ¯” SNR è¶Šå°(å¦‚ SNR=6), ä¿¡å·å°±å˜å¾—æ›´åŠ ä¹±ä¸ƒå…«ç³Ÿ.\nQAM è°ƒåˆ¶ # (è¯è¯´æ˜¯ä¸æ˜¯åº”è¯¥å…ˆè®²ä¸€è®² QAM æ˜¯ä»€ä¹ˆ?)\nQAM æ˜¯ä»€ä¹ˆ? # æ ¹æ®ç»´åŸºç™¾ç§‘:\nQuadrature amplitude modulation (QAM) is the name of a family of digital modulation methods and a related family of analog modulation methods widely used in modern telecommunications to transmit information. It conveys two analog message signals, or two digital bit streams, by changing (modulating) the amplitudes of two carrier waves, using the amplitude-shift keying (ASK) digital modulation scheme or amplitude modulation (AM) analog modulation scheme. The two carrier waves are of the same frequency and are out of phase with each other by 90Â°, a condition known as orthogonality or quadrature. The transmitted signal is created by adding the two carrier waves together. At the receiver, the two waves can be coherently separated (demodulated) because of their orthogonality.\n(å•Š, å¥½é•¿\u0026hellip;)\nä¸€å¥è¯, QAM çš„ä¼ è¾“æ•ˆç‡æ›´é«˜.\næ¯”å¦‚ QAM16 ä¸€æ¬¡å¯ä»¥ä¼ é€’ 4 bit, è€Œ AM ä¸€æ¬¡åªèƒ½ä¼  1 bit.\nå›¾2: å„ç§è°ƒåˆ¶æ–¹æ³•é€šé“å®¹é‡æ¯”è¾ƒ å¯¹äºæœ¬æ–‡ä¸­çš„ QAM çš„å®ç°, ç®€å•æ¥è¯´, å°±æ˜¯ä¸‰æ­¥: 1. å…ˆæŠŠè¾“å…¥æ•°ç»„å‡åˆ†æˆä¸¤ä»½, 2. å†é€šè¿‡å¹…ç§»é”®æ§ (ASK) ç¼–ç , 3. ç„¶åä¹˜ä¸Šå„è‡ªçš„è½½æ³¢å°±OKäº†. å¯ä»¥çœ‹çœ‹ç¤ºæ„å›¾:\nå›¾3: QAMè°ƒåˆ¶ç¤ºæ„å›¾ QAM åŸç† # è‡³äºå®ƒä¸ºä»€ä¹ˆèƒ½å¤ŸæˆåŠŸç¼–ç è§£ç , ç”¨å…¬å¼è¦æ›´å¥½ç†è§£ä¸€ç‚¹.\né¦–å…ˆå°†è¾“å…¥å‡åˆ†ä¸ºä¸¤åŠ, ç„¶ååˆ†åˆ«è®¡ç®—å¾—åˆ°å„è‡ªçš„ ASK ç¼–ç : \\( A_I(t) \\) å’Œ \\( A_Q(t) \\) .\n\\[ I(t) = A_I(t) cos(2\\pi f t) \\\\ Q(t) = A_Q(t) sin(2\\pi f t) \\] å…¶ä¸­, \\( f \\) æ˜¯è½½æ³¢çš„é¢‘ç‡. ç„¶åå°† \\( I(t) \\) å’Œ \\( Q(t) \\) å åŠ , å¾—åˆ°:\n\\[ I(t) + Q(t) = A_I(t) cos(2\\pi f t) + A_Q(t) sin(2\\pi f t) \\] åœ¨è§£ç çš„æ—¶å€™, å…ˆåˆ†åˆ«ä¹˜ä¸Šå„è‡ªçš„è½½æ³¢:\n\\[ (I(t) + Q(t)) cos(2\\pi f t) = \\frac{1}{2} (A_I(t) + A_I(t)cos(4\\pi f t) + A_Q(t)sin(4\\pi f t)) \\] \\[ (I(t) + Q(t)) sin(2\\pi f t) = \\frac{1}{2} (A_Q(t) + A_I(t)cos(4\\pi f t) - A_Q(t)sin(4\\pi f t)) \\] åœ¨è¿‡æ»¤æ‰é«˜é¢‘åˆ†é‡å:\n\\[ Filter((I(t) + Q(t)) cos(2\\pi f t)) \\approx \\frac{1}{2} A_I(t) \\] \\[ Filter((I(t) + Q(t)) sin(2\\pi f t)) \\approx \\frac{1}{2} A_Q(t) \\] å°±å¯ä»¥æˆåŠŸå¾—åˆ° \\( A_I(t) \\) å’Œ \\( A_Q(t) \\) å•¦ ğŸ‰.\nQAM ä»£ç å®ç° # ä¸ºäº†è®©å›¾æ›´å¥½çœ‹, æˆ‘ä»¬æ”¹ä¸€ä¸‹åˆå§‹è¾“å…¥å­—ç¬¦ä¸²å’Œä¿¡å™ªæ¯”:\n# Signal-to-Noise Ratio (SNR) in dB for the simulation snr = 24 # Input string to be transmitted. input_string = \u0026#34;Communications Systems Communication Channel Simulation and Report. In this project, you will complete a simulation of a wireless communication system. This builds on the tasks in Lab 1 and the lectures cover all the background theory for each part of the task.\u0026#34; # input_string = \u0026#34;a?\u0026#34; ä¸ºäº†å®ç°åŠ¨æ€QAM, æˆ‘ä»¬å¸Œæœ›å¯¹äºä¸åŒçš„ä¿¡å™ªæ¯”é€‰æ‹©ä¸åŒçš„QAMæ¨¡å‹(QAM4, QAM16 æˆ–æ˜¯ QAM64). æ­¤å¤„, å¯¹åº”äºä¸Šè¿° snr = 24, å…¶æœ¬ä¼šåŠ¨æ€é€‰æ‹© QAM64, ä½†å‡ºäºå±•ç¤ºç›®çš„, æˆ‘ä»¬å°†å…¶æ‰‹åŠ¨è°ƒæ•´ä¸º QAM16.\n# Dynamically adjust the modulation order based on the Signal-to-Noise Ratio (SNR) if snr \u0026gt;= 28: M = 64 # Use 64-QAM for high SNR, allowing more symbols (6 bits per symbol) for higher data rates elif snr \u0026gt;= 20: M = 16 # Use 16-QAM for moderate SNR, balancing data rate and noise resilience else: M = 4 # Use 4-QAM (QPSK) for low SNR, prioritizing robustness over data rate # if you do NOT want to use dynamic modulation you can use the following instruction. # Default modulation order for QAM (16-QAM) indicating 16 different symbols M = 16 M ä¸€äº›å…¶å®ƒçš„è¡ç”Ÿé‡, ä¸ºäº†æ–¹ä¾¿åé¢çš„è®¡ç®—.\nsqrt_M = int(sqrt(M)) size_symbol = int(log2(M)) n_symbol = int(len(input_string) * (8 / size_symbol)) # number of QAM symbols to create size_symbol, n_symbol å¯¹äº QAM16 å’Œ æŒ‡å®šçš„å‘é€ä¿¡æ¯, size_symbol = 4, n_symbol = 522. å‰è€…è¡¨ç¤ºå…¶â€ä¸€å£æ°”â€œæœ€å¤šå¯ä»¥ä¼ 4bit, ä¹Ÿå°±æ˜¯ä¸€ä¸ª symbol, åè€…è¡¨ç¤ºå¯¹äºç»™å®šçš„ä¿¡æ¯, å®ƒéœ€è¦ä¼  522 symbol.\nç„¶åæ˜¯ä¸¤ä¸ªè½½æ³¢:\n# Define carrier signal parameters f_s = 10000 # Sampling frequency in MHz rep_symbol = 500 # Number of samples used to represent a single QAM symbol max_t = rep_symbol * n_symbol / f_s # Total time duration of the signal print(max_t) t = np.linspace(0, max_t, int(f_s * max_t)) # Generate the time vector for the signal f_c = 100 # Carrier frequency in MHz A_c = 1 # Amplitude of the carrier # Generate the in-phase (I) and quadrature (Q) carrier signals carrier_I = A_c*np.cos(2*np.pi*f_c*t) carrier_Q = A_c*np.sin(2*np.pi*f_c*t) plt.plot(t, carrier_I) plt.xlim(left=0, right=1) è¾“å‡º:\n26.3\nå›¾4: QAM è½½æ³¢ ä»£ç ä¸­æˆ‘ä»¬å¯ä»¥å‘ç°ä¸€ä¸ªå˜é‡ rep_symbol, å®ƒåœ¨ä¸‹åˆ—çš„ä»£ç ä¸­è¢«ç”¨æ¥â€œé‡å¤â€è¾“å…¥æ•°ç»„, å·²å°†å…¶æ‰©å±•ä¸ºæ—¶é—´åºåˆ—, ä»¥æ­¤æ–¹ä¾¿åé¢ç”»å›¾æ—¶æ›´å‡†ç¡®çš„é‡‡æ ·. è€Œf_s æ­£æ˜¯åœ¨è¯è¿™ä¸ªå›¾æ˜¯çš„é‡‡æ ·é¢‘ç‡.\n# Reshape the noisy input into blocks corresponding to QAM symbols input_QAM = input_b_noise.reshape((-1,size_symbol)) print(input_QAM.shape) # Initialize arrays for amplitude components of in-phase (I) and quadrature (Q) A_I = zeros((input_QAM.shape[0],)) A_Q = zeros((input_QAM.shape[0],)) # Amplitude modulation: Calculate the amplitudes for I and Q components for n in range(int(size_symbol / 2)): A_I = A_I + input_QAM[:,n] * 2 ** (int(size_symbol / 2) - 1 - n) A_Q = A_Q + input_QAM[:,n + int(size_symbol / 2)] * 2 ** (int(size_symbol / 2) - 1 - n) # QAM # print(A_I) # print(A_Q) # Generate repeated in-phase amplitude signal to match the time resolution s_I = A_I.reshape(-1, 1).repeat(rep_symbol, 1).reshape(-1) # Modulate the in-phase component with the cosine carrier s_I_mod = s_I * carrier_I # print(s_I) # Generate repeated quadrature amplitude signal to match the time resolution s_Q = A_Q.reshape(-1, 1).repeat(rep_symbol, 1).reshape(-1) # Modulate the quadrature component with the sine carrier s_Q_mod = s_Q * carrier_Q ç„¶åæŠŠè°ƒåˆ¶åçš„ä¿¡å·ç”»å‡ºæ¥:\nplt.figure() plt.plot(t, s_I_mod) plt.plot(t, s_I, linewidth=3) plt.legend([\u0026#34;modulated I\u0026#34;, \u0026#34;I\u0026#34;]) plt.grid() plt.xlim(left=0, right=1) plt.figure() plt.plot(t, s_Q_mod) plt.plot(t, s_Q, linewidth=3) plt.legend([\u0026#34;modulated Q\u0026#34;, \u0026#34;Q\u0026#34;]) plt.grid() plt.xlim(left=0, right=1) s_mod = s_I_mod + s_Q_mod plt.figure() plt.plot(t, s_mod, linewidth=3) plt.xlim(left=0, right=1) # plt.legend([\u0026#34;modulated s\u0026#34;, \u0026#34;s\u0026#34;]) plt.grid() è¾“å‡º:\nå›¾5: QAM è°ƒåˆ¶åçš„ I åˆ†é‡ä¿¡å· å›¾6: QAM è°ƒåˆ¶åçš„ Q åˆ†é‡ä¿¡å· å›¾7: QAM è°ƒåˆ¶åçš„æ€»ä¿¡å· QAM æ˜Ÿåº§å›¾ # ä¸ºäº†ç»˜åˆ¶æ˜Ÿåº§å›¾, æˆ‘ä»¬æœ‰å¦‚ä¸‹å˜é‡å’Œå‡½æ•°:\n# Generate a normalized QAM constellation by representing points in binary format # For example, QAM16: 00, 01, 10, 11 norm_constallation = [bin(x)[2:].zfill(size_symbol // 2) for x in arange(sqrt_M)] norm_constallation def plot_constellation(S, color=\u0026#34;blue\u0026#34;, label=\u0026#39;\u0026#39;): \u0026#34;\u0026#34;\u0026#34; Plots the QAM constellation diagram, showing signal points and the grid of possible symbols. \u0026#34;\u0026#34;\u0026#34; # Separate the real and imaginary parts of the symbols for plotting sx,sy = np.real(S), np.imag(S) # Map to constellation coord k = 2 b = -(sqrt_M - 1) sx = [k * x + b for x in sx] sy = [k * y + b for y in sy] # Plot the symbols as scatter points if label: plt.scatter(sx,sy,s=30, c=color, label=label) else: plt.scatter(sx,sy,s=30, c=color) # Overlay the QAM grid points and annotate them with their binary representations for i, x in enumerate(range(-sqrt_M + 1, sqrt_M, 2)): for j, y in enumerate(range(-sqrt_M + 1, sqrt_M, 2)): plt.scatter(x, y, s=60, c=\u0026#34;r\u0026#34;) plt.annotate(f\u0026#34;{norm_constallation[i]}{norm_constallation[j]}\u0026#34;, xy=(x-0.25, y-0.5)) axis_limit = sqrt_M plt.axis([-axis_limit,axis_limit,-axis_limit,axis_limit]) plt.axhline(0, color=\u0026#39;black\u0026#39;) plt.axvline(0, color=\u0026#39;black\u0026#39;) plt.grid(True) # draw constellation S = A_I + 1j * A_Q print(S[:10]) plot_constellation(S) è¾“å‡º:\n[1.88111148+2.08807572j 3.01975263+0.01366766j 2.05328757+1.12644641j 1.83682459+3.0908774j 2.00044805+2.97572787j 2.9585253 +0.84307519j 1.92937708+3.06050133j 1.07733372+1.0006585j 2.98315354+0.84013525j 2.08884394+1.86715759j]\nå›¾8: QAM16 æ˜Ÿåº§å›¾(å‘é€å‰) è·¯å¾„æŸå¤±æ¨¡æ‹Ÿ Hata Model # # Hata Model for small or medium-sized city. #f_c: in MHz h_b = 30 # height of BS antenna in metres h_m = 2 # height of mobile antenna in matres distance = np.array([1, 2, 3, 4, 5]); #in km C_H = 0.8 + (1.1 * np.log10(f_c) - 0.7) * h_m - 1.56 * np.log10(f_c) L_U = 69.55 + 26.16 * np.log10(f_c) - 13.82 * np.log10(h_b) - C_H + (44.9-6.55*np.log10(h_b))*np.log10(distance) plt.plot(distance, L_U) plt.xlabel(\u0026#39;Distance from transmitter(in km)\u0026#39;) plt.ylabel(\u0026#39;Path loss (in dB)\u0026#39;) plt.grid() output:\nå›¾9: Hata model å¯ä»¥å‘ç°, è·ç¦»è¶Šè¿œ, æŸå¤±è¶Šå¤š.\nQAM è§£è°ƒ # ä¸ºäº†æ–¹ä¾¿è§£è°ƒ, æˆ‘ä»¬å…ˆå†™ä¸€ä¸ªæ»¤æ³¢å™¨å‡ºæ¥:\ndef butter_lowpass_filter(data, cutoff, fs, order): \u0026#39;\u0026#39;\u0026#39; Applies a Butterworth lowpass filter to the given data. \u0026#39;\u0026#39;\u0026#39; # Calculate the Nyquist frequency (half the sampling frequency) nyq = 0.5 * fs # Normalize the cutoff frequency to the Nyquist frequency normal_cutoff = cutoff / nyq # b, a are the filter coefficients b, a = signal.butter(order, normal_cutoff, btype=\u0026#39;low\u0026#39;, analog=False) # Apply the filter to the data using forward-backward filtering y = signal.filtfilt(b, a, data) return y QAM è§£è°ƒä»¥åŠå¯¹åº”çš„æ³¢å½¢:\n# Demodulate the in-phase (I) component # Multiply the received signal by the in-phase carrier and scale by 2 to isolate the I component s_I_demod = s_mod * carrier_I * 2 # Apply the Butterworth lowpass filter to remove high-frequency components s_I_demod = butter_lowpass_filter(s_I_demod, 50, f_s, 2) # Demodulate the quadrature (Q) component # Multiply the received signal by the quadrature carrier and scale by 2 to isolate the Q component s_Q_demod = s_mod * carrier_Q * 2 # Apply the Butterworth lowpass filter to remove high-frequency components s_Q_demod = butter_lowpass_filter(s_Q_demod, 50, f_s, 2) # Plot the modulated and demodulated in-phase components plt.figure() plt.plot(t, s_I_mod) plt.plot(t, s_I_demod) plt.xlim(left=0, right=1) plt.legend([\u0026#34;modulated I\u0026#34;, \u0026#34;demodulated I\u0026#34;]) plt.grid() # Plot the modulated and demodulated quadrature components plt.figure() plt.plot(t, s_Q_mod) plt.plot(t, s_Q_demod) plt.xlim(left=0, right=1) plt.legend([\u0026#34;modulated Q\u0026#34;, \u0026#34;demodulated Q\u0026#34;]) plt.grid() output:\nå›¾10: QAM è§£è°ƒåçš„ I åˆ†é‡ä¿¡å· å›¾11: QAM è§£è°ƒåçš„ Q åˆ†é‡ä¿¡å· å¯¹åº”çš„æ˜Ÿåº§å›¾:\n# Reshape the demodulated signal into blocks of size `rep_symbol` and calculate the average for each block A_I_demod = np.average(s_I_demod.reshape((-1, rep_symbol)), 1) A_Q_demod = np.average(s_Q_demod.reshape((-1, rep_symbol)), 1) print(s_I_demod.reshape((rep_symbol, -1)).shape) print(A_I_demod.shape) # To draw constrllation # Combined in-phase and quadrature components to form complex symbols S_demod = A_I_demod + 1j * A_Q_demod # Plot the constellation plot_constellation(S, label=\u0026#34;Transmitted\u0026#34;) plot_constellation(S_demod, color=\u0026#34;green\u0026#34;, label=\u0026#34;Received\u0026#34;) plt.legend() output:\n(500, 526) (526,) å›¾12: QAM16 æ˜Ÿåº§å›¾(è§£è°ƒå) # Round the demodulated signal\u0026#39;s amplitudes to the nearest integers A_I_demod = [int(round(x)) for x in A_I_demod] A_Q_demod = [int(round(x)) for x in A_Q_demod] # Map the rounded amplitudes to their corresponding binary strings in the normalized constellation output_b = [norm_constallation[min(len(norm_constallation) - 1, int(x))] + norm_constallation[min(len(norm_constallation) - 1, int(y))] for x, y in zip(A_I_demod, A_Q_demod)] # Concatenate all binary strings into a single bitstream output_b = \u0026#39;\u0026#39;.join(output_b) # Decode the bitstream using a Hamming decode function output_b = list(decode(bitarray(output_b))) output_b_int_list = output_b # Convert each binary value in the list to a string for easier manipulation output_b = [str(x) for x in output_b] # Group the binary strings into bytes (8 bits each) for interpretation output_b = [\u0026#39;\u0026#39;.join(output_b[8*i : 8*i + 8]) for i in range(len(output_b) // 8)] print(output_b[:10]) # Convert the grouped binary values back into the original string output_string = bits2string(output_b) print(output_string) output:\n[\u0026#39;01000011\u0026#39;, \u0026#39;01101111\u0026#39;, \u0026#39;01101101\u0026#39;, \u0026#39;01101101\u0026#39;, \u0026#39;01110101\u0026#39;, \u0026#39;01101110\u0026#39;, \u0026#39;01101001\u0026#39;, \u0026#39;01100011\u0026#39;, \u0026#39;01100001\u0026#39;, \u0026#39;01110100\u0026#39;] Communications Systems Communication Channel Simulation and Report. In this project, you will complete a simulation of a wireless communication system. This builds on the tasks in Lab 1 and the lectures cover all the background theory for each part of the task. è¯¯ç ç‡ # print(output_b_int_list[:24]) print(input_b_int_list[:24]) # Initialize the Bit Error Rate (BER) counter BER = 0 # Initialize a list to store the indices of errors error_list = [] # Iterate through pairs of input and output bits (or values) for comparison for i, (input, output) in enumerate(zip(input_b_int_list, output_b_int_list)): if input != output: BER += 1 error_list += [i] # Calculate the BER by dividing the total errors by the length of the output BER /= len(output_b_int_list) print(f\u0026#34;BER is {BER}\u0026#34;) print(f\u0026#34;find error at {error_list}\u0026#34;) output:\n[0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1] [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1] BER is 0.0 find error at [] ååˆ†å®Œç¾!\n"},{"id":2,"href":"/docs/example/my-blog/pns/pns_ch2/","title":"CH2.å·¥ä¸šç”Ÿäº§æ¨¡å‹","section":"å·¥ä¸šç”Ÿäº§è§„åˆ’è°ƒåº¦é˜…è¯»ç¬”è®°","content":" Chapter 2 Manufacturing Models # 2.1 Introduction # 2.2 Jobs, Machines, and Facilities # ä¸€äº›åŸºæœ¬æ¦‚å¿µ:\nThe number of jobs is denoted by n and the number of machines by m. The subscripts j and k refer to jobs j and k. The subscripts h and i refer to machines h and i. The following data pertain to job j.\nä¹Ÿå°±æ˜¯:\njob æ•°: n. æœºå™¨æ•°: m. é™¤æ­¤å¤–, è¿˜æœ‰:\nå¤„ç†æ—¶é—´: ( pijp_{ij} ): represents the time job j has to spend on machine i. æˆªæ­¢æ—¥æœŸ ( djd_{j} ). æƒé‡ ( wjw_j ). job çš„ä¼˜å…ˆçº§ It may represent the cost of keeping job j in the system for one time unit. The weight can be a holding or inventory cost, or it can be the amount of value already added to the job.\nä»¥ä¸Š 4 ä¸ªæ•°æ®å¹¶ç§°ä¸º é™æ€æ•°æ® (static data). å› ä¸ºå®ƒä»¬ä¸ä¾èµ–äºè°ƒåº¦ç®—æ³•. ç›¸å, é‚£äº›ä¸èƒ½æå‰ç¡®å®šå¹¶ä¸”ä¾èµ–äºè°ƒåº¦ç®—æ³•çš„æ•°æ®ç§°ä¹‹ä¸º åŠ¨æ€æ•°æ® (dynamic data). æ¯”è¾ƒé‡è¦çš„åŠ¨æ€æ•°æ®å¦‚ä¸‹:\nStarting time SijS_{ij} : job j å¼€å§‹åœ¨ æœºå™¨i ä¸Šå¤„ç†çš„æ—¶é—´ç‚¹. Completion time CijC_{ij} : å®Œæˆæ—¶é—´. è°ƒåº¦æ¨¡å‹çš„ä¸€ä¸ªé‡è¦ç‰¹å¾æ˜¯å®ƒçš„ æœºå™¨é…ç½® (machine configuration), å¦‚ä¸‹:\nSingle Machine Models: job åªèƒ½å»ä¸€ä¸ªåœ°æ–¹å¤„ç† Parallel Machine Models: job å¯ä»¥é€‰æ‹©å¤šå°æœºå™¨ä¸­çš„å…¶ä¸­ä¸€ä¸ª Flow Shop Models: æ‰€æœ‰çš„ job éƒ½ä¼šç»è¿‡ç›¸åŒçš„å¤„ç† Job Shop Models: job é€šå¸¸æœ‰ä¸åŒçš„å¤„ç† Supply Chain Models a flow shop is a job shop in which each and every job has the same route\n2.3 Processing Characteristics and Constraints # job çš„å¤„ç†ä¹Ÿæœ‰ç‰¹å¾å’Œå¯¹åº”çš„é™åˆ¶.\nPrecedence Constraints: å‰åé™åˆ¶, ä¸€ä¸ª job å¿…é¡»å®Œæˆä¸€ä¸ªå¤„ç†ä¸ªå†è¿›è¡Œä¸‹ä¸€ä¸ªå¤„ç†. Machine Eligibility Constraints: å½“æœºå™¨ä¸å®Œå…¨ä¸€æ ·æ—¶, æœ‰äº›æœºå™¨å¯èƒ½æ²¡æœ‰èµ„æ ¼å®Œæˆå¯¹ç‰¹ç‚¹ job çš„å¤„ç†. Workforce Constraints. Routing Constraints. Material Handling Constraints. Sequence Dependent Setup Times and Costs. Storage Space and Waiting Time Constraints. Make-to-Stockand Make-to-Order. Preemptions. Transportation Constraints. 2.4 Performance Measures and Objectives # ä¸€äº›å…³é”®çš„æè¿°æ€§èƒ½çš„ æµ‹é‡å€¼ å’Œ ç›®æ ‡:\nThroughput and Makespan Objectives. Throughput = output rate Makespan = æ‰€æœ‰å·¥ä½œå…¨éƒ¨å®Œæˆæ‰€éœ€çš„æ€»æ—¶é—´ Cmax=max(C1,...,Cn)Cmax = max(C_1,...,C_n) Due Date Related Objectives. one objective: minimizing the maximum lateness Lateness: Lj=Cjâˆ’djL_j= C_jâˆ’d_j Lmax=max(L1,...,Ln) L_{max} = max(L_1,...,L_n) anather objective: minimizing number of tardy jobs tardiness of job j: Tj=max(Cjâˆ’dj,0)T_j = max(C_jâˆ’d_j,0) âˆ‘j=1nÏ‰jTj\\sum^n_{j=1}\\omega_jT_j Setup Costs. Work-In-Process Inventory Costs. (WIP) Finished Goods Inventory Costs. Transportation Costs. "},{"id":3,"href":"/docs/example/my-blog/pns/pns_ch4/","title":"CH4.é¡¹ç›®çš„è§„åˆ’è°ƒåº¦","section":"å·¥ä¸šç”Ÿäº§è§„åˆ’è°ƒåº¦é˜…è¯»ç¬”è®°","content":" Chapter 4 Project Planning and Scheduling # 4.1 Introduction # æœ¬ç« çš„ä¸€äº›å‰æ:\nThis chapter focuses on the planning and scheduling of jobs that are subject to precedence constraints. The setting may be regarded as a parallel machine environment with an unlimited number of machines.\næˆ‘ä»¬çš„ä¼˜åŒ–ç›®æ ‡:\nThe objective is to minimize the makespan while adhering to the precedence constraints\nä¸¤ä¸ªé™åˆ¶:\nprecedence constraints: æ¯ä¸ª job çš„å¼€å§‹éœ€è¦ç­‰å¾…ä¸Šä¸€ä¸ª job çš„å®Œæˆ. workforce constraints: æ“ä½œå‘˜å¯èƒ½çŸ­ç¼º (å¿™ä¸è¿‡æ¥) job å…ˆåé¡ºåºè¡¨ç¤ºçš„ä¸¤ç§æ–¹å¼: å¯¹äºå‰ä¸€ç§, æ¯ä¸ª arc ä»£è¡¨ job, æ¯ä¸ª node ä»£è¡¨ä¸€ä¸ª epoch. å¯¹äºåä¸€ç§, æ¯ä¸ª node ä»£è¡¨ job, æ¯ä¸ª arc ä»£è¡¨ å…ˆåå…³ç³».\n4.2 Critical Path Method (CPM) # é¦–å…ˆå£°æ˜å¿…è¦çš„ assumptions:\nThe processing time of job j is fixed and equal to $p_j$. unlimited number of machines in parallel. Besides a machine (and there is always one available) a job does not require any other resource. åœ¨æ­¤å‰æä¸‹, è¿™ä¸ªæ–¹æ³•å¯ä»¥è¿™æ ·æè¿°:\nStart at time zero with the processing of all jobs that have no predecessors. Every time a job completes its processing, start processing those jobs of which all the predecessors have been completed.\nä¹Ÿå°±æ˜¯è¯´, ä¸€ä¸ªä¸€ä¸ªæŒ‰é¡ºåºåš.\nä½†æ˜¯ä¸ºäº†æ›´åŠ æ­£å¼çš„æè¿°è¿™ä¸ªç®—æ³•, æˆ‘ä»¬éœ€è¦å¼•å…¥ä»¥ä¸‹ç¬¦å·:\nCjâ€²C\u0026#x27;_j : job j çš„æœ€æ—©å¯èƒ½å®Œæˆæ—¶é—´. Sjâ€²S\u0026#x27;_j : job j çš„æœ€æ—©å¯èƒ½å¼€å§‹æ—¶é—´. pjp_j : job j æ‰€éœ€è¦çš„å¤„ç†æ—¶é—´. {all k -\u0026gt; j}: job j çš„å…¨éƒ¨å‰ç½®. å› æ­¤, æˆ‘ä»¬å¯ä»¥æ‹¥æœ‰ä»¥ä¸‹ä¼ªä»£ç :\nè¿™ä¸ªæ–¹æ³•, æˆ‘ä»¬ç§°ä¹‹ä¸º Forward Procedure. ç„¶è€Œ, å®ƒè™½ç„¶ç®€å•æ˜“æ‡‚, ä½†æ˜¯å®ƒå¹¶ä¸ä¸€å®šèƒ½å¸¦æ¥æœ€ä¼˜çš„æ•ˆç‡. å› ä¸ºå®ƒæœ‰å¯èƒ½å»¶è¿ŸæŸäº› job çš„å¼€å§‹.\nå› æ­¤, æˆ‘ä»¬æ¥ä¸‹æ¥è¦ä»‹ç»å¦ä¸€ä¸ª CPM ç®—æ³•: Backward Procedure. è¿™ä¸ªç®—æ³•åˆ©ç”¨äº† Forward Procedure çš„è¾“å‡º $C_max$ ä½œä¸ºè¾“å…¥, ç„¶åå…¶å®ƒéœ€è¦å®šä¹‰çš„ç¬¦å·å¦‚ä¸‹:\nCjâ€²â€²C^{\\prime\\prime}_j : job j æœ€æ™šå¯èƒ½å®Œæˆæ—¶é—´. Sjâ€²â€²S^{\\prime\\prime}_j : job j æœ€æ™šå¯èƒ½å¼€å§‹æ—¶é—´. {j -\u0026gt; all k}: job j çš„å…¨éƒ¨åç½®. So the forward procedure determines the earliest possible starting time and completion times as well as the minimum makespan.\nåé¢åˆè¡¥å……äº†å‡ ä¸ªæ¦‚å¿µ:\nThe diï¬€erence between a jobâ€™s latest possible starting time and earliest possible starting time is the amount of slack, also referred to as float. A job of which the earliest starting time is equal to the latest starting time is referred to as a critical job. The set of critical jobs forms one or more critical paths. A critical path is a chain of non-slack jobs. 4.3 Program Evaluation and Review Technique (PERT) # 4.4 Time/Cost Trade-Oï¬€s: Linear Costs # 4.5 Time/Cost Trade-Oï¬€s: Nonlinear Costs # 4.6 Project Scheduling with Workforce Constraints # 4.7 ROMAN: A Project Scheduling System for the Nuclear Power Industry # 4.8 Discussion # "}]